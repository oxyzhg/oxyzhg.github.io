<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">事件循环 | FEX</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/fex/docs/forward/javascript/eventloop"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="事件循环 | FEX"><meta data-react-helmet="true" name="description" content="事件循环（Event Loop）是指浏览器或 Node.js 中解决 JavaScript 单线程运行时可能阻塞的一种机制，即异步机制。JavaScript 运行特点是：单线程，非阻塞。"><meta data-react-helmet="true" property="og:description" content="事件循环（Event Loop）是指浏览器或 Node.js 中解决 JavaScript 单线程运行时可能阻塞的一种机制，即异步机制。JavaScript 运行特点是：单线程，非阻塞。"><link data-react-helmet="true" rel="shortcut icon" href="/fex/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/fex/docs/forward/javascript/eventloop"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/fex/docs/forward/javascript/eventloop" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/fex/docs/forward/javascript/eventloop" hreflang="x-default"><link rel="stylesheet" href="/fex/assets/css/styles.c03fb6b8.css">
<link rel="preload" href="/fex/assets/js/runtime~main.5fe59648.js" as="script">
<link rel="preload" href="/fex/assets/js/main.d831a914.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/fex/"><img src="/fex/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/fex/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">FEX</b></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/fex/docs/forward">前端进阶</a><a class="navbar__item navbar__link" href="/fex/docs/engineering">工程化</a><a class="navbar__item navbar__link" href="/fex/docs/performance">性能优化</a><a class="navbar__item navbar__link" href="/fex/docs/practice">开发实践</a><a href="https://github.com/oxyzhg/fex" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/fex/docs/forward">概览</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">JavaScript</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/fex/docs/forward/javascript/inheritance">继承</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/fex/docs/forward/javascript/eventloop">事件循环</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">React</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Vue.js</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Node.js</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">浏览器</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">设计模式</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>事件循环</h1></header><p>事件循环（Event Loop）是指浏览器或 Node.js 中解决 JavaScript 单线程运行时可能阻塞的一种机制，即异步机制。JavaScript 运行特点是：<strong>单线程，非阻塞</strong>。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="执行栈和任务队列"></a>执行栈和任务队列<a class="hash-link" href="#执行栈和任务队列" title="Direct link to heading">#</a></h2><p>JavaScript 有一个 <code>main thread</code> 主线程和 <code>call-stack</code> 执行栈，所有的任务都会被放到执行栈等待主线程依次执行。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="执行栈"></a>执行栈<a class="hash-link" href="#执行栈" title="Direct link to heading">#</a></h3><p>执行栈，也叫调用栈，用于存储在代码执行期间创建的所有执行上下文，具有后进先出的特点。当函数执行时，会被添加到执行栈的顶部，当函数执行完成后，就会从栈顶移出，直到栈被清空。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="任务队列"></a>任务队列<a class="hash-link" href="#任务队列" title="Direct link to heading">#</a></h3><p>任务队列，用于存储异步事件的回调函数，具有先进先出的特点。异步代码的执行，遇到异步事件不会等待它返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当异步事件有了返回结果，将它的回调函数放入相应的任务队列中，被放入任务队列的回调不会立刻执行。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="异步任务"></a>异步任务<a class="hash-link" href="#异步任务" title="Direct link to heading">#</a></h2><p>JavaScript 中任务有两种类型，分别是同步任务和异步任务。异步任务通常又分为 <strong>macro-task</strong>(task) 和 <strong>micro-task</strong>(jobs) 两种，对应的任务队列分别称作宏任务队列和微任务队列。</p><p>引入微任务的原因：页面渲染事件，各种 IO 的完成事件等随时被添加到任务队列中，一直会保持先进先出的原则执行，我们不能准确地控制这些事件被添加到任务队列中的位置。如果此时突然有高优先级的任务需要尽快执行，那么一种类型的任务就不合适了，所以引入了微任务队列。</p><p>可产生<strong>宏任务</strong>的事件有：</p><ul><li>script 整体代码</li><li>setTimeout/setInterval/setImmediate</li><li>postMessage (H5)</li><li>I/O</li><li>UI 交互事件 (H5)</li></ul><p>可产生<strong>微任务</strong>的事件有：</p><ul><li>Promise.then</li><li>async/await</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener noreferrer">MutationObserver</a> (H5)</li><li>process.nextTick (Node.js)</li></ul><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>宏任务和微任务本质上无差，因为它们都是待执行函数，不同的是该任务是由哪种事件产生。相对应的宏任务队列和微任务队列也是如此，不同的是两种任务队列中的任务何时执行、如何执行。通常我们通过产生任务的事件来区分宏任务和微任务。</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="浏览器中事件循环机制"></a>浏览器中事件循环机制<a class="hash-link" href="#浏览器中事件循环机制" title="Direct link to heading">#</a></h2><p>异步事件有了返回结果后，会把其注册的回调函数放入任务队列中，根据异步事件的类型，这个事件实际上会被放入对应的宏任务和微任务队列中去。</p><p>当前执行栈为空时，主线程会检查微任务队列是否有待执行任务存在。如果存在，依次执行任务队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最靠前的一个任务，放入执行栈中执行。如果不存在，那么再去宏任务中取出最靠前的一个任务，放入执行栈中执行。</p><p>同一次时间循环中，微任务永远在宏任务之前执行，每个宏任务执行完成后都会清空微任务队列，这就是微任务比宏任务优先级更高的原因。</p><p>在事件循环中，每进行一次循环操作称为 tick，关键步骤如下：</p><ol><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，产生结果后将回调添加到微任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（微任务优先级高的原因）</li><li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li><li>渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ol><p><img alt="Event Loop" src="/fex/assets/images/eventloop-browser-aa38f11da31f3263b8c12f66cb8a0c49.png"></p><p>简单概括为：执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，直到所有微任务执行完毕，再回到宏任务中进行下一轮循环。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="nodejs-中事件循环机制"></a>Nodejs 中事件循环机制<a class="hash-link" href="#nodejs-中事件循环机制" title="Direct link to heading">#</a></h2><p>在 Node.js 中，事件循环表现出的状态与浏览器中大致相同。不同的是 Node.js 中有一套自己的模型。Node.js 中事件循环的实现是依靠的 libuv 引擎。我们知道 Node.js 选择 chrome v8 引擎作为 js 解释器，v8 引擎将 js 代码分析后去调用对应的 node API，而这些 API 最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。因此实际上 Node.js 中的事件循环存在于 libuv 引擎中。</p><p>最新 Node.js 事件循环操作顺序的简化概览如图所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly basic"><pre tabindex="0" class="prism-code language-basic codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">   ┌───────────────────────────┐</span></span><span class="token-line" style="color:#393A34"><span class="token plain">┌─&gt;│           timers          │</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  └─────────────┬─────────────┘</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  ┌─────────────┴─────────────┐</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  │     pending callbacks     │</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  └─────────────┬─────────────┘</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  ┌─────────────┴─────────────┐</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  │       idle, prepare       │</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  └─────────────┬─────────────┘      ┌───────────────┐</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  ┌─────────────┴─────────────┐      │   incoming:   │</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  │           poll            │&lt;─────┤  connections, │</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  └─────────────┬─────────────┘      │   data, etc.  │</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  ┌─────────────┴─────────────┐      └───────────────┘</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  │           check           │</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  └─────────────┬─────────────┘</span></span><span class="token-line" style="color:#393A34"><span class="token plain">│  ┌─────────────┴─────────────┐</span></span><span class="token-line" style="color:#393A34"><span class="token plain">└──┤      close callbacks      │</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   └───────────────────────────┘</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>注意：每个框被称为事件循环机制的一个阶段。</p><p>每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段，等等。</p><p>阶段概述:</p><ul><li><strong>timer</strong>: 本阶段执行已经被 <code>setTilemout</code> 和 <code>setInterval</code> 的调度回调函数。定时器由轮询阶段控制何时执行。</li><li><strong>pending callbacks</strong>: 执行延迟到下一个循环迭代的 I/O 回调。（某些系统操作，如 TCP 错误类型）</li><li><strong>idle,prepare</strong>: 仅系统内部调用。</li><li><strong>poll</strong>: 检索新的 I/O 事件；执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 <code>setImmediate</code> 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li><li><strong>check</strong>: <code>setImmediate</code> 回调函数在这里执行。此阶段允许人员在轮询阶段完成后立即执行回调。</li><li><strong>close callbacks</strong>: 一些关闭的回调函数，如 <code>socket.on(&#x27;close&#x27;, callback)</code>。</li></ul><p>node 中事件循环的顺序：外部输入数据 -&gt; 轮询阶段 -&gt; 检查阶段 -&gt; 关闭事件回调阶段 -&gt; 定时器阶段 -&gt; 挂起的回调阶段 -&gt; 闲置阶段 -&gt; 轮询阶段 ···</p><p>其中，当事件循环进入轮询阶段且<em>没有被调度的计时器时</em>，将发生以下两种情况之一：</p><ul><li>如果轮询队列不是空的，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。</li><li>如果轮询队列是空的，还有两件事发生：<ul><li>如果脚本被 <code>setImmediate</code> 调度，则事件循环将结束轮询阶段，并继续检查阶段以执行那些被调度的脚本。</li><li>如果脚本未被 <code>setImmediate</code> 调度，则事件循环将等待回调被添加到队列中，然后立即执行。</li></ul></li></ul><p>一旦轮询队列为空，事件循环将检查<em>已达到时间阈值的计时器</em>。如果一个或多个计时器已准备就绪，则事件循环将绕回计时器阶段以执行这些计时器的回调。</p><p>参考资料：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noopener noreferrer">详解 JavaScript 中的 EventLoop 机制</a></li><li><a href="https://segmentfault.com/a/1190000022805523" target="_blank" rel="noopener noreferrer">JavaScript 中的 EventLoop 机制</a></li><li><a href="https://juejin.cn/post/6844903764202094606" target="_blank" rel="noopener noreferrer">一次弄懂 Event Loop（彻底解决此类面试问题）</a></li><li><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop" target="_blank" rel="noopener noreferrer">Node.js 事件循环</a></li><li><a href="https://vimeo.com/96425312" target="_blank" rel="noopener noreferrer">Help, I&#x27;m stuck in an event-loop</a></li><li><a href="https://blog.insiderattack.net/new-changes-to-timers-and-microtasks-from-node-v11-0-0-and-above-68d112743eb3" target="_blank" rel="noopener noreferrer">New Changes to the Timers and Microtasks in Node v11.0.0 (and above)</a></li><li><a href="http://latentflip.com/loupe" target="_blank" rel="noopener noreferrer">Loupe - Loupe is a little visualisation to help you understand how JavaScript&#x27;s call stack/event loop/callback queue interact with each other.</a></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/oxyzhg/fex/edit/main/docs/forward/javascript/eventloop.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/fex/docs/forward/javascript/inheritance"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 继承</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/fex/docs/forward/react/lifecycle"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">生命周期 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#执行栈和任务队列" class="table-of-contents__link">执行栈和任务队列</a><ul><li><a href="#执行栈" class="table-of-contents__link">执行栈</a></li><li><a href="#任务队列" class="table-of-contents__link">任务队列</a></li></ul></li><li><a href="#异步任务" class="table-of-contents__link">异步任务</a></li><li><a href="#浏览器中事件循环机制" class="table-of-contents__link">浏览器中事件循环机制</a></li><li><a href="#nodejs-中事件循环机制" class="table-of-contents__link">Nodejs 中事件循环机制</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/fex/docs/forward">前端进阶</a></li><li class="footer__item"><a class="footer__link-item" href="/fex/docs/interview">前端面试</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.yuque.com/oxyzhg" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>语雀<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://juejin.cn/user/571401775099528" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>掘金<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/oxyzhg" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">© 2021 Oxyzhg</div></div></div></footer></div>
<script src="/fex/assets/js/runtime~main.5fe59648.js"></script>
<script src="/fex/assets/js/main.d831a914.js"></script>
</body>
</html>