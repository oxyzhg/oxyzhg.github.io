<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Source Map 配置分析</title>
      <link href="/post/36fc7ed/"/>
      <url>/post/36fc7ed/</url>
      
        <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>对于开发环境，通常希望更快速的 source map，需要添加到 bundle 文件以增加体积为代价；对于生产环境，通常希望更精确的 source map，需要从 bundle 中分离并独立存在，并且尽量保证 rebuild 速度。</p><h2 id="关键字及作用"><a href="#关键字及作用" class="headerlink" title="关键字及作用"></a>关键字及作用</h2><p>书写格式 <code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code></p><p>关键字说明：</p><ul><li><strong>source-map</strong>: 非 cheap, eval 修饰的类型，最终都会生成 .map 文件，并在 bundle 文件中添加引用注释。</li><li><strong>eval</strong>: 使用 eval 函数包裹源代码。该关键字不会生成单独的 .map 文件。</li><li><strong>cheap</strong>: 没有列映射(column mapping)的 source map，忽略 loader source map。</li><li><strong>inline</strong>: 不会生成单独的 .map 文件，与形如 eval-* 类型生成的代码类似都会添加到 bundle 中。</li><li><strong>module</strong>: 将 loader source map 简化为每行一个映射(mapping)。</li><li><strong>hidden</strong>: 生成 source map 文件，但不会为 bundle 增加引用注释。</li></ul><p>注意点：</p><ul><li>eval, inline 都可以看作是 source map 的修饰符，并且这两者是并列关系，不会同时出现。</li><li>eval, inline 都会将 source map 内容以注释的形式添加到 bundle 中，这会增加 bundle 文件体积，不适用生产环境。</li></ul><h2 id="代码质量说明"><a href="#代码质量说明" class="headerlink" title="代码质量说明"></a>代码质量说明</h2><ul><li><strong>bundled</strong>: 所有生成的代码视作一大块代码。没有相互分离的模块。</li><li><strong>generated</strong>: 每个模块相互分离，并用模块名称进行注释。可以看到 webpack 生成的代码。示例：你会看到类似 <code>var module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42); module__WEBPACK_IMPORTED_MODULE_1__.a();</code>，而不是 <code>import &#123;test&#125; from &quot;module&quot;; test();</code>。</li><li><strong>transformed</strong>: 每个模块相互分离，并用模块名称进行注释。可以看到 loader 转译后、webpack 转换前的代码。示例：你会看到类似 <code>import &#123;test&#125; from &quot;module&quot;; var A = function(_test) &#123; ... &#125;(test);</code>，而不是 <code>import &#123;test&#125; from &quot;module&quot;; class A extends test &#123;&#125;</code>。</li><li><strong>original lines</strong>: 每个模块相互分离，并用模块名称进行注释。可以看到转译前的代码。</li><li><strong>original</strong>: source map 不包含源码内容。浏览器通常会去服务中加载源代码。</li></ul><h2 id="常见配置分析"><a href="#常见配置分析" class="headerlink" title="常见配置分析"></a>常见配置分析</h2><table><thead><tr><th>devtool</th><th>quality</th><th>build</th><th>rebuild</th></tr></thead><tbody><tr><td>eval</td><td>generated</td><td>fast</td><td>fastest</td></tr><tr><td>eval-source-map</td><td>original</td><td>slowest</td><td>ok</td></tr><tr><td>eval-cheap-source-map</td><td>transformed</td><td>ok</td><td>fast</td></tr><tr><td>eval-cheap-module-source-map</td><td>original lines</td><td>slow</td><td>fast</td></tr><tr><td>inline-source-map</td><td>original</td><td>slowest</td><td>slowest</td></tr><tr><td>cheap-source-map</td><td>transformed</td><td>ok</td><td>slow</td></tr><tr><td>inline-cheap-source-map</td><td>transformed</td><td>ok</td><td>slow</td></tr><tr><td>cheap-module-source-map</td><td>original lines</td><td>slow</td><td>slow</td></tr><tr><td>inline-cheap-module-source-map</td><td>original lines</td><td>slow</td><td>slow</td></tr><tr><td>source-map</td><td>original</td><td>slowest</td><td>slowest</td></tr><tr><td>hidden-source-map</td><td>original</td><td>slowest</td><td>slowest</td></tr><tr><td>nosources-source-map</td><td>original</td><td>slowest</td><td>slowest</td></tr></tbody></table><p>分析与总结：</p><ol><li>eval,inline,hidden,nosources 都是不影响 source map 质量的修饰符，它们决定了 source map 以什么形式出现在什么地方。</li><li>形如 *-module-source-map 类型，source map 质量都是 original lines.</li><li>形如 *-cheap-source-map 类型，会影响 source map 质量，最终看到的都是转换后的代码。</li><li>影响 source map 质量的修饰符优先级顺序是：module&gt;cheap&gt;eval=inline=hidden=nosources</li><li>source map 代码质量顺序是：original&gt;original lines&gt;transformed&gt;generated</li><li>inline,hidden,nosources 都不影响 build/rebuild 速度。</li><li>初次构建速度跟代码质量有关系，代码越精简生成速度越快，生成速度顺序是：generated&gt;transform&gt;original lines&gt;original</li><li>对于再次构建来说，形如 eval-* 类型，不会生成 source map 文件，再次构建速度较快，cheap 修饰符也会大幅加快再次构建速度。module 修饰符（webpack5）对再次构建速度的影响可忽略不计。总的来说，是否生成 source map 文件起决定性作用，cheap 等影响代码质量的修饰符因素次之。</li><li>虽然表中 eval 类型在 build/rebuild 两方面表现都非常突出，但由于开发环境我们需要尽可能的映射到源代码，因此尽量在 eval 的基础上选择其他更适合的类型。</li></ol><h2 id="具体应用场景分析"><a href="#具体应用场景分析" class="headerlink" title="具体应用场景分析"></a>具体应用场景分析</h2><h3 id="对于开发环境"><a href="#对于开发环境" class="headerlink" title="对于开发环境"></a>对于开发环境</h3><p><strong>eval</strong></p><p>每个模块都使用 eval 执行，并且都有 <code>//# sourceURL</code>。该项构建很快，但缺点也很明显，由于会映射到转换后的代码，而不是映射到原始代码（没有从 loader 中获取 source map），所以不能正确的显示行数。<em>这种类型一般不使用，映射不准确还不如不用。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">()=&gt;</span>&#123;<span class="built_in">eval</span>(<span class="string">&quot;console.log(1122);document.body.innerHTML=&#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;;\n\n//# sourceURL=webpack://@dotlim/scripts/./example/src/index.js?&quot;</span>)&#125;)();</span><br></pre></td></tr></table></figure><p>映射形式 <code>index.js:1</code></p><p><strong>eval-source-map</strong></p><p>每个模块使用 eval 执行，并且 source map 转换为 DataURL 添加到 eval 中。初始化 source map 时较慢，但是会在重新构建时提供较快的速度，并且生成实际的文件。行数能够正确映射，因为会映射到原始代码中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">()=&gt;</span>&#123;<span class="built_in">eval</span>(<span class="string">&quot;console.log(1122);document.body.innerHTML=&#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZG90bGltL3NjcmlwdHMvLi9leGFtcGxlL3NyYy9pbmRleC5qcz8yNGE3Il0sIm5hbWVzIjpbImNvbnNvbGUiLCJkb2N1bWVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU8sQ0FBUEEsR0FBQUEsQ0FBQUEsSUFBQUEsRUFDQUMsUUFBUSxDQUFSQSxJQUFBQSxDQUFBQSxTQUFBQSxDQUFBQSx1QkFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zb2xlLmxvZygxMTIyKTtcclxuZG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPSAnPGgxPkhlbGxvIHdvcmxkITwvaDE+JztcclxuIl0sImZpbGUiOiI0MTMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///413\n&quot;</span>)&#125;)();</span><br></pre></td></tr></table></figure><p>映射形式 <code>index.js?24a7:1</code></p><p><strong>eval-cheap-source-map</strong></p><p>类似 eval-source-map，但没有生成列映射(column mapping)，只是映射行数。它会忽略源自 loader 的 source map，并且仅显示转译后的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">()=&gt;</span>&#123;<span class="built_in">eval</span>(<span class="string">&quot;console.log(1122);document.body.innerHTML=&#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZG90bGltL3NjcmlwdHMvLi9leGFtcGxlL3NyYy9pbmRleC5qcz8yNGE3Il0sIm5hbWVzIjpbImNvbnNvbGUiLCJkb2N1bWVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU8sQ0FBUEEsR0FBQUEsQ0FBQUEsSUFBQUEsRUFDQUMsUUFBUSxDQUFSQSxJQUFBQSxDQUFBQSxTQUFBQSxDQUFBQSx1QkFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zb2xlLmxvZygxMTIyKTtcclxuZG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPSAnPGgxPkhlbGxvIHdvcmxkITwvaDE+JztcclxuIl0sImZpbGUiOiI0MTMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///413\n&quot;</span>)&#125;)();</span><br></pre></td></tr></table></figure><p>映射形式 <code>index.js?24a7:1 </code></p><p><strong>eval-cheap-module-source-map</strong></p><p>类似 eval-cheap-source-map，在这种情况下，源自 loader 的 source map 会得到更好的处理结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">()=&gt;</span>&#123;<span class="built_in">eval</span>(<span class="string">&quot;console.log(1122);document.body.innerHTML=&#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZG90bGltL3NjcmlwdHMvLi9leGFtcGxlL3NyYy9pbmRleC5qcz8yNGE3Il0sIm5hbWVzIjpbImNvbnNvbGUiLCJkb2N1bWVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU8sQ0FBUEEsR0FBQUEsQ0FBQUEsSUFBQUEsRUFDQUMsUUFBUSxDQUFSQSxJQUFBQSxDQUFBQSxTQUFBQSxDQUFBQSx1QkFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zb2xlLmxvZygxMTIyKTtcclxuZG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPSAnPGgxPkhlbGxvIHdvcmxkITwvaDE+JztcclxuIl0sImZpbGUiOiI0MTMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///413\n&quot;</span>)&#125;)();</span><br></pre></td></tr></table></figure><p>映射形式 <code>index.js?24a7:1</code></p><h3 id="特定场景"><a href="#特定场景" class="headerlink" title="特定场景"></a>特定场景</h3><p><strong>inline-source-map</strong></p><p>source map 转换为 DataUrl 后添加到 bundle 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1122</span>),<span class="built_in">document</span>.body.innerHTML=<span class="string">&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;</span>;</span><br><span class="line"><span class="comment">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZG90bGltL3NjcmlwdHMvLi9leGFtcGxlL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJjb25zb2xlIiwiZG9jdW1lbnQiXSwibWFwcGluZ3MiOiJBQUFBQSxrQkFDQUMiLCJmaWxlIjoianMvbWFpbi45Njc4ZjIwZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnNvbGUubG9nKDExMjIpO1xyXG5kb2N1bWVudC5ib2R5LmlubmVySFRNTCA9ICc8aDE+SGVsbG8gd29ybGQhPC9oMT4nO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9</span></span><br></pre></td></tr></table></figure><p>映射形式 <code>index.js:1</code></p><p><strong>cheap-source-map</strong></p><p>没有列映射(column mapping)的 source map，忽略 loader source map。生成单独的 .map 文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1122</span>),<span class="built_in">document</span>.body.innerHTML=<span class="string">&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;</span>;</span><br><span class="line"><span class="comment">//# sourceMappingURL=main.c20330fd.js.map</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;version&quot;</span>:<span class="number">3</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;js/main.c20330fd.js&quot;</span>,<span class="string">&quot;sources&quot;</span>:[<span class="string">&quot;webpack://@dotlim/scripts/js/main.c20330fd.js&quot;</span>],<span class="string">&quot;sourcesContent&quot;</span>:[<span class="string">&quot;console.log(1122),document.body.innerHTML=\&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;\&quot;;&quot;</span>],<span class="string">&quot;mappings&quot;</span>:<span class="string">&quot;AAAA&quot;</span>,<span class="string">&quot;sourceRoot&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>映射形式 <code>main.c20330fd.js:1</code></p><p><strong>inline-cheap-source-map</strong></p><p>类似 cheap-source-map，但是 source map 转换为 DataURL 添加到 bundle 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1122</span>),<span class="built_in">document</span>.body.innerHTML=<span class="string">&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;</span>;</span><br><span class="line"><span class="comment">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMvbWFpbi45Njc4ZjIwZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL0Bkb3RsaW0vc2NyaXB0cy9qcy9tYWluLjk2NzhmMjBlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnNvbGUubG9nKDExMjIpLGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MPVwiPGgxPkhlbGxvIHdvcmxkITwvaDE+XCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==</span></span><br></pre></td></tr></table></figure><p>映射形式 <code>main.9678f20e.js:1</code></p><p><strong>cheap-module-source-map</strong></p><p>没有列映射(column mapping)的 source map，将 loader source map 简化为每行一个映射(mapping)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1122</span>),<span class="built_in">document</span>.body.innerHTML=<span class="string">&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;</span>;</span><br><span class="line"><span class="comment">//# sourceMappingURL=main.c20330fd.js.map</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;version&quot;</span>:<span class="number">3</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;js/main.c20330fd.js&quot;</span>,<span class="string">&quot;sources&quot;</span>:[<span class="string">&quot;webpack://@dotlim/scripts/js/main.c20330fd.js&quot;</span>],<span class="string">&quot;mappings&quot;</span>:<span class="string">&quot;AACA&quot;</span>,<span class="string">&quot;sourceRoot&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>映射形式 <code>main.c20330fd.js:2</code> 【靓仔疑惑??不准】</p><p><strong>inline-cheap-module-source-map</strong></p><p>类似 cheap-module-source-map，但是 source map 转换为 DataURL 添加到 bundle 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1122</span>),<span class="built_in">document</span>.body.innerHTML=<span class="string">&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;</span>;</span><br><span class="line"><span class="comment">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMvbWFpbi45Njc4ZjIwZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL0Bkb3RsaW0vc2NyaXB0cy9qcy9tYWluLjk2NzhmMjBlLmpzIl0sIm1hcHBpbmdzIjoiQUFDQSIsInNvdXJjZVJvb3QiOiIifQ==</span></span><br></pre></td></tr></table></figure><p>映射形式 <code>main.9678f20e.js:2</code></p><h3 id="对于生产环境"><a href="#对于生产环境" class="headerlink" title="对于生产环境"></a>对于生产环境</h3><p><strong>source-map</strong></p><p>整个 source map 作为一个单独的文件生成。它为 bundle 添加了一个引用注释，以便开发工具知道在哪里可以找到它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1122</span>),<span class="built_in">document</span>.body.innerHTML=<span class="string">&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;</span>;</span><br><span class="line"><span class="comment">//# sourceMappingURL=main.c20330fd.js.map</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;version&quot;</span>:<span class="number">3</span>,<span class="string">&quot;sources&quot;</span>:[<span class="string">&quot;webpack://@dotlim/scripts/./example/src/index.js&quot;</span>],<span class="string">&quot;names&quot;</span>:[<span class="string">&quot;console&quot;</span>,<span class="string">&quot;document&quot;</span>],<span class="string">&quot;mappings&quot;</span>:<span class="string">&quot;AAAAA,kBACAC&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;js/main.c20330fd.js&quot;</span>,<span class="string">&quot;sourcesContent&quot;</span>:[<span class="string">&quot;console.log(1122);\r\ndocument.body.innerHTML = &#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;;\r\n&quot;</span>],<span class="string">&quot;sourceRoot&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>hidden-source-map</strong></p><p>与 source-map 相同，但不会为 bundle 添加引用注释。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1122</span>),<span class="built_in">document</span>.body.innerHTML=<span class="string">&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;version&quot;</span>:<span class="number">3</span>,<span class="string">&quot;sources&quot;</span>:[<span class="string">&quot;webpack://@dotlim/scripts/./example/src/index.js&quot;</span>],<span class="string">&quot;names&quot;</span>:[<span class="string">&quot;console&quot;</span>,<span class="string">&quot;document&quot;</span>],<span class="string">&quot;mappings&quot;</span>:<span class="string">&quot;AAAAA,kBACAC&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;js/main.d211ed7f.js&quot;</span>,<span class="string">&quot;sourcesContent&quot;</span>:[<span class="string">&quot;console.log(1122);\r\ndocument.body.innerHTML = &#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;;\r\n&quot;</span>],<span class="string">&quot;sourceRoot&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>映射形式 <code>main.d211ed7f.js:1</code></p><p><strong>nosources-source-map</strong></p><p>创建的 source map 不包含 <code>sourcesContent</code>。它可以用来映射客户端上的堆栈跟踪，而无须暴露所有的源代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1122</span>),<span class="built_in">document</span>.body.innerHTML=<span class="string">&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;</span>;</span><br><span class="line"><span class="comment">//# sourceMappingURL=main.c20330fd.js.map</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;version&quot;</span>:<span class="number">3</span>,<span class="string">&quot;sources&quot;</span>:[<span class="string">&quot;webpack://@dotlim/scripts/./example/src/index.js&quot;</span>],<span class="string">&quot;names&quot;</span>:[<span class="string">&quot;console&quot;</span>,<span class="string">&quot;document&quot;</span>],<span class="string">&quot;mappings&quot;</span>:<span class="string">&quot;AAAAA,kBACAC&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;js/main.c20330fd.js&quot;</span>,<span class="string">&quot;sourceRoot&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>映射形式 <code>index.js:1</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> source-map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令清单</title>
      <link href="/post/a9a6c8b0/"/>
      <url>/post/a9a6c8b0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1.新建仓库"></a>1.新建仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p>Git 的设置文件为 _.gitconfig_，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-增加-删除文件"><a href="#3-增加-删除文件" class="headerlink" title="3.增加/删除文件"></a>3.增加/删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h2 id="4-代码提交"><a href="#4-代码提交" class="headerlink" title="4.代码提交"></a>4.代码提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h2 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h2 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h2 id="7-查看信息"><a href="#7-查看信息" class="headerlink" title="7.查看信息"></a>7.查看信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h2 id="8-远程同步"><a href="#8-远程同步" class="headerlink" title="8.远程同步"></a>8.远程同步</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="9-撤销"><a href="#9-撤销" class="headerlink" title="9.撤销"></a>9.撤销</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h2 id="10-其他"><a href="#10-其他" class="headerlink" title="10.其他"></a>10.其他</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure><hr><ul><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单 - 阮一峰</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git-bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/post/11d8b32d/"/>
      <url>/post/11d8b32d/</url>
      
        <content type="html"><![CDATA[<p>实现继承的方法，无非就是获得父类的实例或原型属性和方法。下面几种方法，会通过不同的方式获得父类的属性和方法，继承到当前子类，从而实现继承。</p><h2 id="常见继承方式"><a href="#常见继承方式" class="headerlink" title="常见继承方式"></a>常见继承方式</h2><p>定义父类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="built_in">this</span>.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在睡觉！&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在吃：&#x27;</span> + food);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>核心：将父类的实例作为子类的原型（仅继承原型，没继承实例）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.name = <span class="string">&#x27;cat&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">&#x27;fish&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li><li>父类新增原型方法/属性，子类都能访问到</li><li>简单，易于实现</li></ol><p>缺点：</p><ol><li>想要给子类新增原型方法/属性，必须在 <code>new Animal()</code> 实例化之后执行，不能放到构造器中</li><li>无法实现多继承</li><li>来自原型对象的引用属性所有实例共享（原型上的方法尽量不要使用，所以子类实例共享）</li><li>创建子类实例时，无法向父类构造函数传参（在定义子类时已初始化父类实例）</li></ol><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>核心：使用父类构造函数来增强子类实例，等于是复制父类的实例属性给子类（仅继承实例，没继承原型）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">&#x27;fish&#x27;</span>)); <span class="comment">// TypeError: cat.eat is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>解决了原型链继承中，子类实例共享父类引用属性的问题（实例化子类时继承父类）</li><li>创建子类实例时，可以向父类传递参数</li><li>可以实现多继承（call 多个父类对象）</li></ol><p>缺点：</p><ol><li>实例并不是父类的实例，只是子类的实例</li><li>只能继承父类的实例属性和方法，不能继承父类的原型属性和方法</li><li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能【疑惑】</li></ol><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后将父类的实例作为子类原型，实现函数复用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比构造继承就多了下面这行</span></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat);</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>弥补了构造函数继承的缺陷，可以继承实例属性和方法，也可以继承原型属性和方法</li><li>即是子类的实例，也是父类的实例</li><li>不存在引用属性共享问题</li><li>可传参</li><li>函数可复用</li></ol><p>缺点：</p><ol><li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li></ol><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>核心：为父类实例添加新属性或方法，是父类实例的再增强</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="keyword">new</span> Animal();</span><br><span class="line">  instance.name = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">&#x27;fish&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>不限调用方式，不管是直接执行还是通过 <code>new</code> 调用子类构造函数，返回的对象具有相同的效果（存在 <code>return</code>）</li></ol><p>缺点：</p><ol><li>实例是父类的实例，不是子类的实例（没有子类）</li><li>不支持多继承</li></ol><h3 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    Cat.prototype[p] = animal[p];</span><br><span class="line">  &#125;</span><br><span class="line">  Cat.prototype.name = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>支持多继承</li></ol><p>缺点：</p><ol><li>效率较低，内存占用高（因为要拷贝父类的属性）</li><li>无法获取父类不可枚举的方法（不可枚举的方法不能使用 <code>for...in</code> 访问）</li></ol><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>核心：通过寄生方式，砍掉父类的实例属性，这样在调用两次父类的构造函数时，就不会初始化两次实例方法和属性，避免组合继承的缺点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cat6.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Cat6.prototype.constructor = Cat6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>特点：堪称完美</p><p>缺点：实现相对复杂</p><h2 id="ES6-extends-关键字"><a href="#ES6-extends-关键字" class="headerlink" title="ES6 extends 关键字"></a>ES6 extends 关键字</h2><p>ES6 extends 关键字实际上就是寄生组合式继承的语法糖，因此也证明了这种方式是较优的解决继承的方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面列了几种继承方式：原型链继承、构造函数继承、组合继承、寄生式继承、寄生式组合继承。这些继承方式各有特点，目的都是通过继承获取父类的实例或原型属性和方法为子类所用。</p><p>它们之间的区别主要取决于怎么使用父类。若是实例化父类，能得到父类的实例和原型方法；若是执行父类的构造函数，只能得到父类的实例，得不到父类的原型。</p><ul><li><strong>原型链继承</strong><ul><li>在定义子类时实例化父类，因此不能在实例化子类时向父类传参，也不能实现多继承</li><li>子类的原型就是父类的实例，子类的原型能继承父类的原型，但是子类的实例不能继承父类的实例</li><li>子类的原型出现了多余的父类实例，引用类型数据使用存在问题</li></ul></li><li><strong>构造函数继承</strong><ul><li>在实例化子类时执行父类构造函数增强子类，因此能在实例化子类时向父类传参，也能实现多继承</li><li>子类的实例就是父类的实例的加强版，但是子类没有继承父类的原型</li><li>不能实现函数的复用，子类有父类实例函数的副本</li></ul></li><li><strong>组合继承</strong><ul><li>是原型链继承（继承原型）和构造函数继承（继承实例）的结合版</li><li>在实例化子类时执行父类构造函数增强子类，同样能向父类传参，也能实现多继承</li><li>子类的原型就是父类的实例的加强版，子类继承了父类的原型</li></ul></li><li><strong>寄生式组合继承</strong><ul><li>与组合继承的区别在于处理原型继承的操作，增加了一步纯函数继承父类的原型，再通过实例化纯函数将无实例属性和方法的实例给到子类原型</li><li>实现了子类的原型只继承父类原型，而没有多余的实例属性</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提交高质量的 Git Commit Message</title>
      <link href="/post/eaa638cc/"/>
      <url>/post/eaa638cc/</url>
      
        <content type="html"><![CDATA[<p>我们选择业内使用较广的 <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">Angular 团队规范</a>，关于 Git Commit Message 的约束，需要注意几点：</p><ol><li><strong>提交格式</strong>：按照 Commit Message Format 规范提交，必选属性是 type, subject，如：<code>feat: 新增应用市场管理功能</code>。（注意 subject 前面的<strong>英文冒号</strong>和<strong>空格</strong>）</li><li><strong>提交内容</strong>：subject 须直观的表述本次修改内容，便于代码回溯。</li></ol><h2 id="Commit-Message-Format"><a href="#Commit-Message-Format" class="headerlink" title="Commit Message Format"></a>Commit Message Format</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>上述提交信息的格式，当前我们只要求写明 <strong>type</strong> 和 <strong>subject</strong> 即可，其他字段不做过多要求，subject 可选中英文，但必须直观的表述本次修改的内容。</p><p>关于上述提交信息 type 的说明：</p><ul><li><strong>feat</strong>—新功能</li><li><strong>fix</strong>—修复 Bug</li><li><strong>docs</strong>—更新文档</li><li><strong>style</strong>—代码格式修改</li><li><strong>refactor</strong>—代码重构</li><li><strong>perf</strong>—性能优化</li><li><strong>test</strong>—更新测试用例</li><li><strong>chore</strong>—其他修改</li></ul><h2 id="相关配置（可选）"><a href="#相关配置（可选）" class="headerlink" title="相关配置（可选）"></a>相关配置（可选）</h2><p>以下依赖可以辅助你达到这些要求：</p><ul><li><a href="https://github.com/commitizen/cz-cli">commitizen</a></li><li><a href="https://github.com/commitizen/cz-conventional-changelog">cz-conventional-changelog</a></li></ul><p>项目级安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commitizen cz-conventional-changelog -D</span><br></pre></td></tr></table></figure><p>修改 <em>package.json</em> 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commit&quot;</span>: <span class="string">&quot;git-cz&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;node_modules/cz-conventional-changelog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令行提交，如下图所示：</p><p>上述依赖可以全局安装，也可以项目级安装。但我们建议在本地全局安装，这样会减少项目在执行 <code>npm install</code> 时安装依赖的数量，从而加快 CI/CD 构建。</p><h2 id="提交信息校验（可选）"><a href="#提交信息校验（可选）" class="headerlink" title="提交信息校验（可选）"></a>提交信息校验（可选）</h2><p>除此之外，在项目中还可以通过 Husky 配置 Lint 校验 Commit Message。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git-commit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问就跟他聊—Vue全家桶</title>
      <link href="/post/9b942608/"/>
      <url>/post/9b942608/</url>
      
        <content type="html"><![CDATA[<h2 id="他想问什么"><a href="#他想问什么" class="headerlink" title="他想问什么"></a>他想问什么</h2><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ol><li>核心特性是什么</li><li>MVVM 原理</li><li>响应式数据原理</li><li>为什么要采用异步渲染</li><li>nextTick 实现原理</li></ol><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><h2 id="他想听什么"><a href="#他想听什么" class="headerlink" title="他想听什么"></a>他想听什么</h2><h3 id="响应式数据原理"><a href="#响应式数据原理" class="headerlink" title="响应式数据原理"></a>响应式数据原理</h3><ol><li>追踪变化：通过劫持数据来追踪变化，在 vue2 中使用 <code>Object.defineProperty</code> 拦截，在 vue3 中使用 <code>Proxy</code> 拦截。</li><li>依赖收集：定义响应式数据后，若监听器使用该数据便触发 getter，然后 Watcher 收集数据发布者，Dep 收集数据订阅者。</li><li>派发更新：当数据模型发生变化，即触发 setter，然后数据发布者 Dep 会通知数据收集者 Watcher，执行 <code>watcher.update</code> 进行更新。</li></ol><h3 id="异步更新-渲染原因"><a href="#异步更新-渲染原因" class="headerlink" title="异步更新/渲染原因"></a>异步更新/渲染原因</h3><p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据能避免不必要的计算和 DOM 操作。然后，在下一个的事件循环 tick 中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p><h3 id="nextTick-实现原理"><a href="#nextTick-实现原理" class="headerlink" title="nextTick 实现原理"></a>nextTick 实现原理</h3><p>该实现使用了事件循环的特性，先是将待执行函数缓存起来，同时使用能够产生异步任务的方法生成异步任务，等同步代码执行完成后，该异步任务会执行并清空缓存的待执行函数。</p><p>其中产生异步任务的方法(<code>Promise.then</code>, <code>MutationObservable</code>, <code>setImmediate</code>, <code>setTimeout</code>)会根据环境嗅探，最终确定使用哪一个，可能是 microtask 也可能是 macrotask，前两个属于微任务，后两个属于宏任务。</p><h2 id="你得知道什么"><a href="#你得知道什么" class="headerlink" title="你得知道什么"></a>你得知道什么</h2><ul><li>vue 核心特性是数据驱动(MVVM)</li><li>响应式数据原理，简单来说是劫持数据 getter/setter 进行依赖收集和派发更新。</li><li>nextTick 实现原理，简单来说是利用了事件循环的特性。</li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html">深入响应式原理</a></li><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97">深入响应式原理-异步更新队列</a></li><li><a href="https://juejin.cn/post/6857669921166491662">图解 Vue 响应式原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 问就跟他聊系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码风格</title>
      <link href="/post/1e0ddd5d/"/>
      <url>/post/1e0ddd5d/</url>
      
        <content type="html"><![CDATA[<blockquote><p>看完你们项目的源码，就知道你们团队有多少个人。</p></blockquote><p>各种命名风格，各种冗余代码，各种缩进风格，各种奇葩注释和各种没有注释，_眼中有码，心中无码_，只有心累两个字。项目的整洁度会受到很多客观因素的影响，为了自己的身心健康，我们应该试图将这种影响降到最低。简单地说，统一格式和风格的代码让人更加赏心悦目，更不容易让你产生想摔键盘的冲动。说的更有 B 格，叫做<strong>熵减</strong>，也就是降低团队产出代码的无序性，如果你想在未来成为一名合格的前端架构师，这将是你的工作目标。</p><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>代码风格通常体现在编辑器行为上，我们通过 editorconfig 跨编辑器约束。</p><p>在项目的根目录创建 <em>.editorconfig</em> 文件，文件内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">root</span> <span class="string">=</span> <span class="literal">true</span>                      <span class="comment"># 表明是最顶层的配置文件</span></span><br><span class="line"></span><br><span class="line">[<span class="string">*</span>]                              <span class="comment"># 正则*匹配所有文件</span></span><br><span class="line"><span class="string">charset</span> <span class="string">=</span> <span class="string">utf-8</span>                  <span class="comment"># 编码格式</span></span><br><span class="line"><span class="string">end_of_line</span> <span class="string">=</span> <span class="string">lf</span>                 <span class="comment"># 定义换行符</span></span><br><span class="line"><span class="string">indent_style</span> <span class="string">=</span> <span class="string">space</span>             <span class="comment"># 缩进方式</span></span><br><span class="line"><span class="string">indent_size</span> <span class="string">=</span> <span class="number">2</span>                  <span class="comment"># 缩进空格数</span></span><br><span class="line"><span class="string">trim_trailing_whitespace</span> <span class="string">=</span> <span class="literal">true</span>  <span class="comment"># 是否去处行首行尾的空白字符</span></span><br><span class="line"><span class="string">insert_final_newline</span> <span class="string">=</span> <span class="literal">true</span>      <span class="comment"># 文件是否以空白行结尾</span></span><br><span class="line"></span><br><span class="line">[<span class="string">*.md</span>]                           <span class="comment"># 正则匹配以.md结尾的文件</span></span><br><span class="line"><span class="string">trim_trailing_whitespace</span> <span class="string">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>文本换行方式使用 LF</li><li>代码缩进使用 2 个空格，不使用 Tab</li><li>所有文件最后留一行空行</li></ul><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。</p><p>前端常见的命名方式：<strong>kebab-case</strong>、<strong>Pascal</strong>、<strong>camelCase</strong>、<strong>snake_case</strong>、大写命名等。</p><h3 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h3><ul><li>通常采用 <strong>kebab-case</strong> 方式命名（这是业内最常见的目录命名方式）</li><li>对于组件文件来说，命名方式有两种：<ul><li>在 React 项目中，推荐使用 <strong>Pascal</strong> 方式命名</li><li>在 Vue 项目中，推荐使用 <strong>kebab-case</strong> 方式命名，官方推荐</li></ul></li><li>此外也可使用 <strong>camelCase</strong> 方式命名，这种命名方式在一些类库中常见，通常是导入导出某个方法等</li><li>不管采用哪种命名方式，在项目中同类型目录/文件命名尽可能保持一致</li><li>禁止采用上述命名方式以外的命名方法，更不能糅合多种命名方式</li><li>有复数结构时，要采用复数命名法</li></ul><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><ul><li>普通变量采用 <strong>camelCase</strong> 方式命名</li><li>对于构造函数，统一采用 <strong>Pascal</strong> 方式命名，普通函数仍采用 <strong>camelCase</strong> 方式命名</li><li>特殊场景下允许使用 <strong>snake_case</strong> 方式命名，常见于解构赋值</li><li>命名尽可能语义化，尽量不要模糊命名</li><li>推荐命名规则<ul><li>类名/属性名/变量名一般是名词，或是形容词+名词</li><li>方法一般是动词，或是动词+名词</li></ul></li><li>禁止糅合多种命名方式</li></ul><h2 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h2><ul><li>组件文件名应与组件名保持一致</li><li>如果组件文件命名为 <code>index.(js|jsx|ts|tsx|vue)</code>，那么主文件夹名称应与组件名称一致</li><li>组件名称/组件文件名称应尽可能语义化，体现组件存在的意义</li><li>一个文件仅包含一个组件</li><li>某个组件的样式文件，应与组件文件名保持一致</li><li>在功能设计之初，应对组件进行合理拆分，保证组件文件代码量不能太长</li><li>合理区别业务组件还是通用组件，如果是通用组件更应考虑多场景适用性</li><li>对于组件用到较多的常量，或常量是多文件共享，应提取成单文件</li><li>对于多组件/文件频繁使用的逻辑，应以纯函数的形式提取成单文件</li><li>以 <code>handle</code> 开头的事件处理方法，如 <code>handleClick</code></li><li>以 <code>on</code> 开头的事件处理方法，如 <code>onFormSubmit</code>，建议用 <code>handle</code></li></ul><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><ul><li>始终坚持单向数据流和单一数据源的原则</li><li>状态不要通过 props 多层传递，如需经过多层传递，建议使用 vuex 或状态管理库</li><li>不一定所有的数据处理都使用 vuex，对于特定场景的数据应存在组件状态中，并写明备注</li></ul><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><ul><li>不建议使用行内样式</li><li>不建议直接在 JSX 文件中导入 CSS 文件</li><li>建议使用 CSS Modules 或 CSS in JS 方案</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释的原则：<code>as short as possible, as long as necessary.</code></p><ul><li>每个类/构造函数的定义都应附带注释，描述类的功能和用法，除非它的功能相当明显</li><li>关键纯函数/公共函数的定义应附带注释</li><li>关键变量/常量应附带注释</li><li>复杂代码逻辑应附带注释</li><li>特殊标记注释：如 <code>TODO</code> , <code>FIXME</code> 等有特殊含义的标记</li><li>文件注释不做要求，除非有必要</li></ul><p>相关资料：<a href="https://jsdoc.app/">JSDoc 文档</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>【建议】代码中未使用到的外部引入代码尽量移除或注释，尤其是在 ES Module 模块化方案中（webpack 虽然有 tree-shaking 优化，但是优化是在优化生成 assets 阶段进行，编译阶段仍然要去递归查找）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码风格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GitHub Actions增量部署静态博客</title>
      <link href="/post/5f53d984/"/>
      <url>/post/5f53d984/</url>
      
        <content type="html"><![CDATA[<blockquote><p>怎么用 Hexo 等搭建静态博客，业内已经有非常多的文章教程了，这里不再赘述。而使用 Github Actions 自动化部署静态博客，很多方案可行但差强人意。经过几次采坑后，我找到了静态博客自动化部署的答案。</p></blockquote><p>GitHub Actions Deploy file:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2.3.1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">persist-credentials:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">and</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          npx hexo generate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@3.7.1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ACCESS_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">gh-pages</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span></span><br><span class="line">          <span class="attr">REPOSITORY_NAME:</span> <span class="string">oxyzhg/oxyzhg.github.io</span></span><br></pre></td></tr></table></figure><p>自动部署主要借助 <a href="https://github.com/JamesIves/github-pages-deploy-action">JamesIves/github-pages-deploy-action</a> 提供的方案。它相较于其他部署方案有着更广范的适用性，并且其增量构建特性是 <code>hexo deploy</code> 不能达到的，这也是我选择它的一个重要原因。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解JavaScript中的执行上下文和执行栈</title>
      <link href="/post/471757d4/"/>
      <url>/post/471757d4/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p>简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p><h3 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h3><p>有三种执行上下文类型类型：</p><ul><li><strong>全局执行上下文</strong>：这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li><strong>函数执行上下文</strong>：每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建。</li><li><strong>Eval 函数执行上下文</strong>：执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于我们并不经常使用 eval，所以在这里不讨论它。</li></ul><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来<strong>存储代码运行时创建的所有执行上下文</strong>。</p><h2 id="如何创建执行上下文"><a href="#如何创建执行上下文" class="headerlink" title="如何创建执行上下文"></a>如何创建执行上下文</h2><p>创建执行上下文有两个阶段：创建阶段和执行阶段。</p><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><p>在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p><ol><li>绑定 this</li><li>创建词法环境组件</li><li>创建变量环境组件</li></ol><p>简单表示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  ThisBinding = <span class="xml"><span class="tag">&lt;<span class="name">this</span> <span class="attr">value</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  LexicalEnvironment = &#123; ... &#125;,</span></span><br><span class="line"><span class="xml">  VariableEnvironment = &#123; ... &#125;,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h4><p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code> 引用 Window 对象)。</p><p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 undefined（在严格模式下）。</p><h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><p><a href="http://ecma-international.org/ecma-262/6.0/">ECMA2015</a>把词法环境定义为</p><blockquote><p>词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。</p></blockquote><p>简单来说，词法环境是一种<strong>标识符—变量</strong>映射的结构。（标识符指变量/函数的名字，而变量指对实际数据的引用）</p><p>词法环境的内部有两个组件：</p><ol><li><strong>环境记录器</strong>：指存储变量和函数声明的实际位置</li><li><strong>外部环境的引用</strong>：意味着它可以访问其父级词法环境（作用域）</li></ol><p>词法环境有两种存在场景：</p><ul><li>全局环境：全局环境的外部环境引用是 null。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 this 的值指向全局对象。</li><li>函数环境：函数内部用户定义的变量存储在环境记录器中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</li></ul><p>对应的环境记录器也有两种类型：</p><ul><li>全局环境中，是对象环境记录器</li><li>函数环境中，是声明式环境记录器。特别地，还包含一个传递给函数的 <code>arguments</code> 对象和传递给函数的参数的 <code>length</code></li></ul><p>抽象地讲，词法环境在伪代码中看起来像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  <span class="attr">LexicalEnvironment</span>: &#123;</span><br><span class="line">    <span class="attr">EnvironmentRecord</span>: &#123;</span><br><span class="line">      <span class="attr">Type</span>: <span class="string">&quot;Object&quot;</span>,</span><br><span class="line">      <span class="comment">// 在这里绑定标识符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">outer</span>: &lt;<span class="literal">null</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  <span class="attr">LexicalEnvironment</span>: &#123;</span><br><span class="line">    <span class="attr">EnvironmentRecord</span>: &#123;</span><br><span class="line">      <span class="attr">Type</span>: <span class="string">&quot;Declarative&quot;</span>,</span><br><span class="line">      <span class="comment">// 在这里绑定标识符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">outer</span>: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">or</span> <span class="attr">outer</span> <span class="attr">function</span> <span class="attr">environment</span> <span class="attr">reference</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h4><p>它同样是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。如上所述，变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。</p><p>在 ES6 中，词法环境和变量环境的区别是前者被用来存储函数声明和变量（<code>let</code>/<code>const</code>）绑定，而后者只用来存储 <code>var</code> 变量绑定。</p><p>我们看点样例代码来理解上面的概念：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>上面代码执行上下文抽象成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">ThisBinding</span>: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>只有函数被调用时，才会创建函数执行上下文</li><li>在执行上下文创建阶段，通过 <code>let</code>/ <code>const</code> 创建的变量存在于词法环境且不会初始化，通过 <code>var</code> 创建的变量存在于变量环境且被初始化为 <code>undefined</code>，这就是为什么 let/const 不存在变量提升的原因。</li></ol><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>在此阶段，完成对所有这些变量的分配，最后执行代码。如果引擎不能在源码中声明的实际位置找到 <code>let</code> 变量的值，它会被赋值为 <code>undefined</code>。</p><hr><p>相关资料：</p><ul><li><a href="https://juejin.cn/post/6844903682283143181">理解 JavaScript 中的执行上下文和执行栈</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 执行上下文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问就跟他聊—执行上下文</title>
      <link href="/post/18bcf77b/"/>
      <url>/post/18bcf77b/</url>
      
        <content type="html"><![CDATA[<h2 id="他想问什么"><a href="#他想问什么" class="headerlink" title="他想问什么"></a>他想问什么</h2><ol><li>执行上下文是什么</li><li>执行上下文有哪些类型</li><li>什么是执行栈</li><li>创建执行上下文两个阶段分别是什么</li><li>怎么理解词法环境</li><li>怎么理解变量对象/环境记录器</li><li>为什么 let/const 不存在变量提升</li></ol><h2 id="他想听什么"><a href="#他想听什么" class="headerlink" title="他想听什么"></a>他想听什么</h2><h2 id="你得知道什么"><a href="#你得知道什么" class="headerlink" title="你得知道什么"></a>你得知道什么</h2><p>• 执行上下文有三种：全局执行上下文、函数执行上下文、Eval 函数执行上下文<br>• 执行上下文创建阶段发生三件事：绑定 this、创建词法环境组件、创建变量环境组件<br>• this 的值取决于该函数是如何被调用<br>• 词法环境有环境记录器和外部环境引用两个组件</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://juejin.cn/post/6844903682283143181">理解 JavaScript 中的执行上下文和执行栈</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 问就跟他聊系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 执行上下文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问就跟他聊—数据类型</title>
      <link href="/post/20e680d8/"/>
      <url>/post/20e680d8/</url>
      
        <content type="html"><![CDATA[<h2 id="他想问什么"><a href="#他想问什么" class="headerlink" title="他想问什么"></a>他想问什么</h2><ol><li>数据类型有哪些（8 种）</li><li>类型检查方法有哪些</li><li>类型转换，触发隐式转换的场景，number 类型转换规则，相等和严格相等</li><li>typeof 运算符</li><li>instanceof 的原理、实现</li><li>运算符优先级</li><li>变量定义，var/let/const</li><li>声明提升</li></ol><h2 id="他想听什么"><a href="#他想听什么" class="headerlink" title="他想听什么"></a>他想听什么</h2><h2 id="你得知道什么"><a href="#你得知道什么" class="headerlink" title="你得知道什么"></a>你得知道什么</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures">数据类型</a>有 8 种：number, string, boolean, null, undefined, symbol, bigint, object</li><li>类型检查方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a>, instanceof, Object.prototype.toString</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a> 运算结果</li><li>instanceof 原理是递归查原型</li><li>类型转换分为显式和隐式</li><li>触发隐式类型转换的场景：运算, 条件判断, 值比较</li><li>number 类型转换规则（注意 undefined）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E7%9B%B8%E7%AD%89">普通相等</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Strict_equality">严格相等</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">JavaScript 中的相等性判断</a></li><li>隐式转换只发生在不同类型，且优先转换成数值型</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">运算符优先级</a></li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2>]]></content>
      
      
      <categories>
          
          <category> 问就跟他聊系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问就跟他聊—概览</title>
      <link href="/post/77cd4175/"/>
      <url>/post/77cd4175/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列是面向前端面试，形成特定知识体系的一个系列。前端知识的特点是零散，面试题也是五花八门，总能从一个点延伸出来更多题目，而解决这些问题的核心思想大多是可类比的，因此我决定把他们串联起来。以下是我在准备面试的过程中，边学习、边回忆、边记录、边整理而成的产物，并开放给前端准备面试的同学们，让大家在准备面试的过程中能够有目的、有方向，希望能起到穿针引线的作用。如果文中有疏漏、错误，或者你有更好的理解，请评论留言或联系我，我们的目标是攻克前端面试！</p></blockquote><h2 id="课题目录"><a href="#课题目录" class="headerlink" title="课题目录"></a>课题目录</h2><ol><li><a href="/post/20e680d8/">问就跟他聊—数据类型</a></li><li><a href="/post/18bcf77b/">问就跟他聊—执行上下文</a></li><li><a href="/post/9b942608/">问就跟他聊—Vue 全家桶</a></li></ol><h2 id="课题规划"><a href="#课题规划" class="headerlink" title="课题规划"></a>课题规划</h2><p>JavaScript:</p><ul><li><input checked="" disabled="" type="checkbox"> 数据类型</li><li><input checked="" disabled="" type="checkbox"> 执行上下文</li><li><input disabled="" type="checkbox"> 原型</li><li><input disabled="" type="checkbox"> 继承</li><li><input disabled="" type="checkbox"> 闭包</li><li><input disabled="" type="checkbox"> this</li><li><input disabled="" type="checkbox"> 事件循环</li><li><input disabled="" type="checkbox"> Promise</li></ul><p>Vuejs:</p><ul><li><input disabled="" type="checkbox"> 响应式原理</li><li><input disabled="" type="checkbox"> MVVM 原理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 问就跟他聊系列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack构建优化分析</title>
      <link href="/post/97c23243/"/>
      <url>/post/97c23243/</url>
      
        <content type="html"><![CDATA[<p>在 Compiler 和 Compilation 的工作流程中耗时分析：</p><ul><li>对于 Compiler 实例而言，耗时最长的显然是生成编译过程实例后的 make 阶段，在这个阶段里，会执行模块编译到优化的完整过程。</li><li>对于 Compilation 实例的工作流程来说，不同的项目和配置各有不同，但总体而言，编译模块和后续优化阶段的生成产物并压缩代码的过程都是比较耗时的。</li></ul><p>不同项目的构建，在整个流程的前期初始化阶段与最后的产物生成阶段的构建时间区别不大。真正影响整个构建效率的还是 Compilation 实例的处理过程，这一过程又可分为两个阶段：编译模块和优化处理。</p><h2 id="编译阶段优化分析"><a href="#编译阶段优化分析" class="headerlink" title="编译阶段优化分析"></a>编译阶段优化分析</h2><p>编译模块阶段所耗的时间是从单个入口点开始，编译每个模块的时间的总和。要提升这一阶段的构建效率，大致可以分为三个方向：</p><ol><li>减少执行编译的模块</li><li>提升单个模块构建的速度</li><li>并行构建以提升总体效率</li></ol><h3 id="减少执行编译的模块"><a href="#减少执行编译的模块" class="headerlink" title="减少执行编译的模块"></a>减少执行编译的模块</h3><p>如果一个项目每次构建都需要编译 1000 个模块，但是通过分析后发现其中有 500 个不需要编译，显而易见，经过优化后，构建效率可以大幅提升。</p><h4 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h4><p>有的依赖包，除了项目所需的模块内容外，还会附带一些多余的模块。典型的例子是 moment 这个包，一般情况下在构建时会自动引入其 locale 目录下的多国语言包，但对于大多数情况而言，项目中只需要引入本国语言包即可。而 Webpack 提供的 IgnorePlugin 即可在构建模块时直接剔除那些需要被排除的模块，从而提升构建模块的速度，并减少产物体积。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.IgnorePlugin(&#123;</span><br><span class="line">      <span class="attr">resourceRegExp</span>: <span class="regexp">/^\.\/locale$/</span>,</span><br><span class="line">      contextRegExp: <span class="regexp">/moment$/</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="按需引入类库模块"><a href="#按需引入类库模块" class="headerlink" title="按需引入类库模块"></a>按需引入类库模块</h4><p>这种方式一般适用于工具类库性质的依赖包的优化，典型例子是 lodash 依赖包。要解决这个问题，效果最佳的方式是在导入声明时只导入依赖包内的特定模块。除了在导入时声明特定模块之外，还可以使用 babel-plugin-lodash 或 babel-plugin-import 等插件达到同样的效果。</p><blockquote><p>关于 Tree Shaking 这里要注意两点：1. 该功能依赖 ES Module 模块化方案；2.该功能在优化阶段进行，换句话说，这并不能对模块编译阶段起作用。</p></blockquote><h4 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h4><p>DllPlugin 的核心思想是将项目依赖的框架等模块单独构建打包，与普通构建流程区分开。例如，原先一个依赖 react 与 react-dom 的项目，经过 DllPlugin 和 DllReferencePlugin 优化后，再次构建的效率会得到极大的提高。</p><h4 id="Externals"><a href="#Externals" class="headerlink" title="Externals"></a>Externals</h4><p>Webpack 配置中的 externals 和 DllPlugin 解决的是同一类问题：将依赖的框架等模块从构建过程中移除。它们的区别在于：</p><ol><li>在配置方面，externals 更简单，而 DllPlugin 需要独立的配置文件。</li><li>DllPlugin 包含了依赖包的独立构建流程，而 externals 配置中不包含依赖框架的生成方式，通常使用已传入 CDN 的依赖包。</li><li>externals 配置的依赖包需要单独指定依赖模块的加载方式：全局对象、CommonJS、AMD 等。</li><li>在引用依赖包的子模块时，DllPlugin 无须更改，而 externals 则会将子模块打入项目包中。</li></ol><h3 id="提升单个模块构建的速度"><a href="#提升单个模块构建的速度" class="headerlink" title="提升单个模块构建的速度"></a>提升单个模块构建的速度</h3><p>提升编译阶段效率的第二个方向，是在保持构建模块数量不变的情况下，提升单个模块构建的速度。具体来说，是通过减少构建单个模块时的一些处理逻辑来提升速度。</p><h4 id="include-exclude"><a href="#include-exclude" class="headerlink" title="include/exclude"></a>include/exclude</h4><p>include 的用途是只对符合条件的模块使用指定 Loader 进行转换处理。而 exclude 则相反，不对特定条件的模块使用该 Loader. 例如不使用 babel-loader 处理 node_modules 中的模块。</p><h4 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h4><p>module.noParse 是在上述 include/exclude 的基础上，进一步省略了使用默认 js 模块编译器进行编译。</p><h4 id="SourceMap"><a href="#SourceMap" class="headerlink" title="SourceMap"></a>SourceMap</h4><p>对于生产环境的代码构建而言，会根据项目实际情况判断是否开启 Source Map。在开启 Source Map 的情况下，优先选择与源文件分离的类型，例如 “source-map”。</p><h4 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h4><p>Webpack 中的 resolve 配置制定的是在构建时指定查找模块文件的规则，例如：</p><ul><li><strong>resolve.modules</strong>：指定查找模块的目录范围。</li><li><strong>resolve.extensions</strong>：指定查找模块的文件类型范围。</li><li><strong>resolve.mainFields</strong>：指定查找模块的 package.json 中主文件的属性名。</li><li><strong>resolve.symlinks</strong>：指定在查找模块时是否处理软连接。</li></ul><p>这些规则在处理每个模块时都会有所应用，因此尽管对小型项目的构建速度来说影响不大，但对于大型的模块众多的项目而言，这些配置的变化就可能产生客观的构建时长区别。</p><h3 id="并行构建以提升总体效率"><a href="#并行构建以提升总体效率" class="headerlink" title="并行构建以提升总体效率"></a>并行构建以提升总体效率</h3><h4 id="thread-loader"><a href="#thread-loader" class="headerlink" title="thread-loader"></a>thread-loader</h4><p>它作用于模块编译的 Loader 上，用于在特定 Loader 的编译过程中，以开启多进程的方式加速编译。</p><h2 id="打包阶段优化分析"><a href="#打包阶段优化分析" class="headerlink" title="打包阶段优化分析"></a>打包阶段优化分析</h2><p>Webpack 编译过程可以细分为 12 个阶段：生成依赖项、生成 Chunk、优化 Module、优化 Chunk、优化 Tree、优化 ChunkModules、生成 Module Ids、生成 Chunk Ids、生成 Hash、生成 ModuleAssets、生成 ChunkAssets、优化 Assets。每个任务依次对数据进行一定的处理，并将结果传递给下一任务。</p><p>因此，这一阶段的优化也可以分为两个不同的方向：</p><ol><li>针对某些任务，使用效率更高的工具或配置项，从而<strong>提升当前任务的工作效率</strong>。</li><li>提升特定任务的优化效果，以减少传递给下一任务的数据量，从而<strong>提升后续环节的工作效率</strong>。</li></ol><h3 id="提升当前任务的工作效率"><a href="#提升当前任务的工作效率" class="headerlink" title="提升当前任务的工作效率"></a>提升当前任务的工作效率</h3><p>一般在项目的优化阶段，主要耗时的任务有两个：一个是生成 ChunkAssets，即根据 Chunk 信息<strong>生成 Chunk 的产物代码</strong>；另一个是优化 Assets，即<strong>压缩 Chunk 产物代码</strong>。</p><p>第一个任务主要在 Webpack 引擎内部的模块中处理，相对而言优化手段较少，主要集中在利用缓存方面。而在压缩 Chunk 产物代码的过程中会用到一些第三方插件，选择不同的插件，以及插件中的不同配置都可能会对其中的效率产生影响。</p><h4 id="面向-JS-的压缩工具"><a href="#面向-JS-的压缩工具" class="headerlink" title="面向 JS 的压缩工具"></a>面向 JS 的压缩工具</h4><p>Webpack4 内置了 TerserWebpackPlugin 作为 JS 压缩工具。（之前的版本是 UglifyJSWebpackPlugin）</p><p>TerserWebpackPlugin 工作过程中，对执行效率产生影响的配置主要分为 3 个方面：</p><ol><li><strong>Cache 选项</strong>：默认开启，使用缓存能够极大程度上提升再次构建时的工作效率。</li><li><strong>Parallel 选项</strong>：默认开启，并发选项在大多数情况下能够提升该插件的工作效率，但具体提升的程度则因项目而异。在小型项目中，多进程通信的额外消耗可能会抵消其带来的益处。</li><li><strong>terserOptions 选项</strong>：即 Terser 工具中的 <a href="https://github.com/terser/terser#minify-options">minify</a> 选项集合。这些选项是对具体压缩处理过程产生影响的配置项。</li></ol><p>我们主要来看其中的 compress 和 mangle 选项，不同选项的压缩结果如下面的代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码./src/example-terser-opts.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = <span class="string">&#x27;1234&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(HelloWorld, foo)</span><br><span class="line">&#125;</span><br><span class="line">HelloWorld()</span><br><span class="line"><span class="comment">//默认配置项compress=&#123;&#125;, mangle=true的压缩后代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">e,t</span>)</span>&#123;!<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(e,<span class="string">&quot;1234&quot;</span>)&#125;()&#125;&#125;);</span><br><span class="line"><span class="comment">//compress=false的压缩后代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">e,r</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> e=<span class="string">&quot;1234&quot;</span>;<span class="built_in">console</span>.log(t,e)&#125;t()&#125;&#125;);</span><br><span class="line"><span class="comment">//mangle=false的压缩代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>,<span class="built_in">exports</span></span>)</span>&#123;!<span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(HelloWorld,<span class="string">&quot;1234&quot;</span>)&#125;()&#125;&#125;);</span><br><span class="line"><span class="comment">//compress=false，mangle=false的压缩后代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>,<span class="built_in">exports</span></span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> foo=<span class="string">&quot;1234&quot;</span>;<span class="built_in">console</span>.log(HelloWorld,foo)&#125;HelloWorld()&#125;&#125;);</span><br></pre></td></tr></table></figure><p>从上面例子可以看出：</p><ul><li><strong>compress</strong> 参数的作用是执行特定的压缩策略，例如省略变量赋值的语句，从而将变量的值直接替换到引入变量的位置上，减小代码体积。而当 compress 参数为 false 时，这类压缩策略不再生效，对压缩质量的影响有限。</li><li><strong>mangle</strong> 参数的作用是对源代码中的变量与函数名称进行压缩，对代码压缩的效果影响非常大。</li></ul><h4 id="面向-CSS-的压缩工具"><a href="#面向-CSS-的压缩工具" class="headerlink" title="面向 CSS 的压缩工具"></a>面向 CSS 的压缩工具</h4><p>CSS 同样有几种压缩工具可供选择：</p><ul><li>OptimizeCSSAssetsPlugin（在 Create-React-App 中使用）</li><li>OptimizeCSSNanoPlugin（在 VUE-CLI 中使用）</li><li>CSSMinimizerWebpackPlugin（2020 年 Webpack 社区新发布的 CSS 压缩插件）</li></ul><p>这三个插件在压缩 CSS 代码功能方面，都默认基于 <a href="https://cssnano.co/">cssnano</a> 实现，因此在压缩质量方面没有什么差别。在压缩效率方面，最新发布的 CSSMinimizerWebpackPlugin 支持了缓存和多进程，这是另外两个工具不具备的。</p><h3 id="提升后续环节的工作效率"><a href="#提升后续环节的工作效率" class="headerlink" title="提升后续环节的工作效率"></a>提升后续环节的工作效率</h3><p>优化阶段的另一类优化方向是通过对本环节的处理减少后续环节处理内容，以便提升后续环节的工作效率。比如：Split Chunks（分包） 和 Tree Shaking（摇树）。</p><h4 id="Split-Chunks"><a href="#Split-Chunks" class="headerlink" title="Split Chunks"></a>Split Chunks</h4><blockquote><p>Split Chunks（分包）是指在 Chunk 生成之后，将原先以入口点来划分的 Chunks 根据一定的规则（例如异步引入或分离公共依赖等原则），分离出子 Chunk 的过程。</p></blockquote><p>Split Chunks 有诸多优点，例如有利于缓存命中、有利于运行时的持久化文件缓存等。其中有一类情况能提升后续环节的工作效率，即通过分包来抽离多个入口点引用的公共依赖。</p><p>Webpack4 内置了 SplitChunksPlugin 插件，该插件在 production 模式下默认启用。其默认的分包规则只会分离动态引入的模块，在处理动态引入的模块时能够自动分离其中的公共依赖。而对于多入口静态引用相同依赖包的情况，则不会处理分包，因此我们需要配置 <code>chunks:&#39;all&#39;</code> 将所有的依赖情况都进行分包处理，从而减少了重复引入相同模块代码的情况。</p><h4 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h4><blockquote><p>Tree Shaking（摇树）是指在构建打包过程中，移除那些引入但未被使用的代码（Dead-code elimination）。</p></blockquote><p>注意几点：</p><ol><li><strong>ES Module</strong>：只有通过 ESM 导入导出的模块才能被 Tree Shaking 命中，这得益于 ESM 能在编译阶段对依赖进行静态分析。</li><li><strong>引入方式</strong>：以 default 方式引入的模块，无法被 Tree Shaking 命中；而引入单个导出对象的方式，无论是使用 <code>import * as xxx</code>  的语法，还是 <code>import &#123;xxx&#125;</code>  的语法，都可以 Tree Shaking 命中。</li><li><strong>SideEffects</strong>：在 Webpack4 中，会根据依赖模块 package.json 中的 sideEffects 属性来确认对应的依赖包代码是否会产生副作用。只有 sideEffects 为 false 的依赖包（或不在 sideEffects 对应数组中的文件），才可以实现安全移除未使用代码的功能。</li><li><strong>Babel</strong>：在 babel7 之前的版本的 babel-preset-env 中，modules 默认是 commonjs，因此在处理模块时，即使原来是 ESM 模块化方案也会被变异成 commonjs 方案，而无法在优化阶段被 TreeShaking 命中；而在 babel7 中，modules 默认为 auto，这样在转换中如果是 ESM 模块不会被转换为 commonjs，也能在后面的优化阶段被 TreeShaking 命中。</li></ol><h2 id="优化方案总结"><a href="#优化方案总结" class="headerlink" title="优化方案总结"></a>优化方案总结</h2><p><strong>编译阶段优化：</strong></p><ol><li>减少执行编译的模块<ol><li>IgnorePlugin</li><li>按需引入</li><li>DllPlugin</li><li>Externals</li></ol></li><li>提升单个模块编译速度<ol><li>include/exclude</li><li>noParse</li><li>SourceMap</li><li>Resolve</li></ol></li><li>并行构建<ol><li>thread-loader</li></ol></li></ol><p><strong>打包阶段优化：</strong></p><ol><li>提升当前任务的工作效率<ol><li>压缩 JS</li><li>压缩 CSS</li></ol></li><li>提升后续环节的工作效率<ol><li>Split Chunks</li><li>Tree Shaking</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> webpack </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack完整的构建流程</title>
      <link href="/post/1a943f3e/"/>
      <url>/post/1a943f3e/</url>
      
        <content type="html"><![CDATA[<h2 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><p>通常，在项目中有两种运行 Webpack 的方式：</p><p>1.基于命令行的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --config webpack.config.js</span><br></pre></td></tr></table></figure><p>2.基于代码的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config&#x27;</span>);</span><br><span class="line">webpack(config, <span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="webpack-js-中的基本流程"><a href="#webpack-js-中的基本流程" class="headerlink" title="webpack.js 中的基本流程"></a>webpack.js 中的基本流程</h3><p>无论用哪种方式运行，本质上都是执行 <a href="https://github.com/webpack/webpack/blob/webpack-4/lib/webpack.js">webpack.js</a> 中的 Webpack 函数。这一函数的核心逻辑是：</p><ol><li>校验 options</li><li>处理 options 默认值</li><li>根据配置生成编译器实例 compiler</li><li>处理参数中的插件</li><li>分析参数，根据参数加载不同内部插件</li><li>如果有回调函数，根据是否是 watch 模式来决定要执行 compiler.watch 还是 compiler.run</li><li>返回 compiler 实例</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="function">(<span class="params">options, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 校验 options</span></span><br><span class="line">  <span class="comment">// 2. 处理 options 默认值</span></span><br><span class="line">  options = <span class="keyword">new</span> WebpackOptionsDefaulter().process(options);</span><br><span class="line">  <span class="comment">// 3. 实例化 compiler</span></span><br><span class="line">  <span class="keyword">let</span> compiler = <span class="keyword">new</span> Compiler(options.context);</span><br><span class="line">  <span class="comment">// 4. 处理插件</span></span><br><span class="line">  <span class="keyword">if</span> (options.plugins &amp;&amp; <span class="built_in">Array</span>.isArray(options.plugins)) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. 分析参数，加载内部插件</span></span><br><span class="line">  compiler.options = <span class="keyword">new</span> WebpackOptionsApply().process(options, compiler); <span class="comment">// 分析参数，加载各内部插件</span></span><br><span class="line">  <span class="comment">// 6. 处理回调函数，根据是否监听分为2种</span></span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options.watch) &#123;</span><br><span class="line">      <span class="keyword">return</span> compiler.watch(watchOptions, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    compiler.run(callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 7. 返回 compiler 实例</span></span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Compiler-js-中的基本流程"><a href="#Compiler-js-中的基本流程" class="headerlink" title="Compiler.js 中的基本流程"></a>Compiler.js 中的基本流程</h3><p>编译器实例类内部逻辑在 <a href="https://github.com/webpack/webpack/blob/webpack-4/lib/Compiler.js">Compiler.js</a> 中，这里分析抽象 compiler.run 函数，了解其主要的执行流程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> <span class="keyword">extends</span> <span class="title">Tapable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">watch</span>(<span class="params">watchOptions, handler</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> finalCallback = <span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onCompiled = <span class="function">(<span class="params">err, compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.emitAssets(compilation, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.emitRecords(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> stats = <span class="keyword">new</span> Stats(compilation);</span><br><span class="line">          stats.startTime = startTime;</span><br><span class="line">          stats.endTime = <span class="built_in">Date</span>.now();</span><br><span class="line">          <span class="built_in">this</span>.hooks.done.callAsync(stats, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line">            <span class="keyword">return</span> finalCallback(<span class="literal">null</span>, stats);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行切入点</span></span><br><span class="line">    <span class="built_in">this</span>.hooks.beforeRun.callAsync(<span class="built_in">this</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.hooks.run.callAsync(<span class="built_in">this</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.readRecords(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">this</span>.compile(onCompiled);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">readRecords</span>(<span class="params">callback</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">compile</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> params = <span class="built_in">this</span>.newCompilationParams();</span><br><span class="line">    <span class="built_in">this</span>.hooks.beforeCompile.callAsync(params, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.hooks.compile.call(params);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> compilation = <span class="built_in">this</span>.newCompilation(params);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.hooks.make.callAsync(compilation, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line"></span><br><span class="line">        compilation.finish(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line"></span><br><span class="line">          compilation.seal(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.hooks.afterCompile.callAsync(compilation, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> callback(<span class="literal">null</span>, compilation);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">newCompilationParams</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">newCompilation</span>(<span class="params">params</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">emitAssets</span>(<span class="params">compilation, callback</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>readRecords</strong>：读取构建记录，用于分包缓存优化，在未设置 recordsPath 时直接返回。</li><li><strong>compile 的主要构建流程</strong>：，涉及以下几各环节：<ol><li><strong>newCompilationParams</strong>：创建 NormalModule 和 ContextModule 的工厂实例，用于创建后续模块实例。</li><li><strong>newCompilation</strong>：创建编译过程 Compilation 实例。</li><li><strong>compiler.hooks.make.callAsync</strong>：触发 make 的 Hook，执行所有监听 make 的插件。</li><li><strong>compilation.finish</strong>：编译过程实例的 finish 方法，触发相应的 Hook 并报告构建模块的错误和警告。</li><li><strong>compilation.seal</strong>：编译过程实例的 seal 方法。</li></ol></li><li><strong>emitAssets</strong>：调用 compilation.getAssets()，将产物内容写入输出文件中。</li><li><strong>emitRecords</strong>：对应第一步的 readRecords，用于写入构建记录，在未设置 recordsPath 时直接返回。</li></ol><blockquote><p>我们可以看到，即使代码经过抽象简化，仍然存在不少的逻辑代码，阅读的方法是从切入点开始，跳过定义的回调函数，直接看执行部分，这样就会形成一条明确的函数调用链，这会对理解整个过程有很大帮助。</p></blockquote><h3 id="Compilation-js-中的基本流程"><a href="#Compilation-js-中的基本流程" class="headerlink" title="Compilation.js 中的基本流程"></a>Compilation.js 中的基本流程</h3><p>这部分的源码位于 <a href="https://github.com/webpack/webpack/blob/webpack-4/lib/Compilation.js">Compilation.js</a> 中。在编译执行过程中，我们主要从外部调用的是两个方法：</p><ul><li><strong>addEntry</strong>：从 entry 开始递归添加和构建模块。</li><li><strong>seal</strong>：冻结模块，进行一系列优化，以及触发各优化阶段的 Hooks。</li></ul><p>以上就是执行 Webpack 构建时的基本流程，这里再稍做总结：</p><ol><li>创建编译器 Compiler 实例。</li><li>根据 Webpack 参数加载参数中的插件，以及程序内置插件。</li><li>执行编译流程：创建编译过程 Compilation 实例，从入口递归添加与构建模块，模块构建完成后冻结模块，并进行优化。</li><li>构建与优化过程结束后提交产物，将产物内容写到输出文件中。</li></ol><h2 id="Webpack-生命周期"><a href="#Webpack-生命周期" class="headerlink" title="Webpack 生命周期"></a>Webpack 生命周期</h2><p>Webpack 工作流程中最核心的两个模块：<strong>Compiler</strong> 和 <strong>Compilation</strong> 都扩展自 Tapable 类，用于实现工作流程中的生命周期划分，以便在不同的生命周期节点上注册和调用插件。</p><h3 id="Webpack-中的插件"><a href="#Webpack-中的插件" class="headerlink" title="Webpack 中的插件"></a>Webpack 中的插件</h3><p>Webpack 引擎基于插件系统搭建而成，不同的插件各司其职，在 Webpack 工作流程的某一个或多个时间点上，对构建流程的某个方面进行处理。Webpack 就是通过这样的工作方式，在各生命周期中，经一系列插件将源代码逐步变成最后的产物代码。</p><p>一个 Webpack 插件是一个包含 <strong>apply</strong> 方法的 JavaScript 对象。这个 apply 方法的执行逻辑，通常是注册 Webpack 工作流程中某一生命周期 Hook，并添加对应 Hook 中该插件的实际处理函数。</p><h3 id="Hooks-的使用方式"><a href="#Hooks-的使用方式" class="headerlink" title="Hooks 的使用方式"></a>Hooks 的使用方式</h3><p>Hook 的使用分为四步：</p><ol><li>在构造函数中定义 Hook 类型和参数，生成 Hook 对象。</li><li>在插件中注册 Hook，添加对应 Hook 触发时的执行函数。</li><li>生成插件实例，运行 apply 方法。</li><li>在运行到对应生命周期节点时调用 Hook，执行注册过的插件的回调函数。</li></ol><p>如下面的代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/Compiler.js</span></span><br><span class="line"><span class="built_in">this</span>.hooks = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">make</span>: <span class="keyword">new</span> SyncHook([<span class="string">&#x27;compilation&#x27;</span>, <span class="string">&#x27;params&#x27;</span>]), <span class="comment">// 1.定义Hook</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">this</span>.hooks.make.call(compilation, params); <span class="comment">// 4.调用Hook</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/dependencies/CommonJsPlugin.js</span></span><br><span class="line"><span class="comment">// 2.在插件中注册Hook</span></span><br><span class="line">compiler.hooks.make.tap(<span class="string">&quot;CommonJSPlugin&quot;</span>, <span class="function">(<span class="params">compilation, &#123; contextModuleFactory, normalModuleFactory &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/WebpackOptionsApply.js</span></span><br><span class="line"><span class="comment">// 3.生成插件实例，运行apply方法</span></span><br><span class="line"><span class="keyword">new</span> CommonJsPlugin(options.module).apply(compiler);</span><br></pre></td></tr></table></figure><p>通过这种方式，Webpack 将编译器和编译过程的生命周期节点提供给外部插件，从而搭建起弹性化的工作引擎。</p><p>Hook 的类型按照同步或异步、是否接收上一插件的返回值等情况分为 9 种。不同类型的 Hook 接收注册的方法也不同，更多信息可参照<a href="https://github.com/webpack/tapable#tapable">官方文档</a>。</p><h3 id="Compiler-Hooks"><a href="#Compiler-Hooks" class="headerlink" title="Compiler Hooks"></a>Compiler Hooks</h3><p>构建器实例的生命周期可以分为 3 个阶段：初始化阶段、构建过程阶段、产物生成阶段。</p><p><strong>初始化阶段</strong></p><ul><li>environment、afterEnvironment：在创建完 compiler 实例且执行了配置内定义的插件的 apply 方法后触发。</li><li>entryOption、afterPlugins、afterResolvers：在 WebpackOptionsApply.js 中，这 3 个 Hooks 分别在执行 EntryOptions 插件和其他 Webpack 内置插件，以及解析了 resolver 配置后触发。</li></ul><p><strong>构建过程阶段</strong></p><ul><li>normalModuleFactory、contextModuleFactory：在两类模块工厂创建后触发。</li><li>beforeRun、run、watchRun、beforeCompile、compile、thisCompilation、compilation、make、afterCompile：在运行构建过程中触发。</li></ul><p><strong>产物生成阶段</strong></p><ul><li>shouldEmit、emit、assetEmitted、afterEmit：在构建完成后，处理产物的过程中触发。</li><li>failed、done：在达到最终结果状态时触发。</li></ul><h3 id="Compilation-Hooks"><a href="#Compilation-Hooks" class="headerlink" title="Compilation Hooks"></a>Compilation Hooks</h3><p>构建过程实例的生命周期我们分为 2 个阶段：构建阶段、优化阶段。</p><p><strong>构建阶段</strong></p><ul><li>addEntry、failedEntry、succeedEntry：在添加入口和添加入口结束时触发（Webpack 5 中移除）。</li><li>buildModule、rebuildModule、finishRebuildingModule、failedModule、succeedModule：在构建单个模块时触发。</li><li>finishModules：在所有模块构建完成后触发。</li></ul><p><strong>优化阶段</strong></p><ul><li>seal、needAdditionalSeal、unseal、afterSeal：分别在 seal 函数的起始和结束的位置触发。</li><li>optimizeDependencies、afterOptimizeDependencies：触发优化依赖的插件执行，例如 FlagDependencyUsagePlugin。</li><li>beforeChunks、afterChunks：分别在生成 Chunks 的过程的前后触发。</li><li>optimize：在生成 chunks 之后，开始执行优化处理的阶段触发。</li><li>optimizeModule、afterOptimizeModule：在优化模块过程的前后触发。</li><li>optimizeChunks、afterOptimizeChunks：在优化 Chunk 过程的前后触发，用于 Tree Shaking。</li><li>optimizeTree、afterOptimizeTree：在优化模块和 Chunk 树过程的前后触发。</li><li>optimizeChunkModules、afterOptimizeChunkModules：在优化 ChunkModules 的过程前后触发，例如 ModuleConcatenationPlugin，利用这一 Hook 来做 Scope Hoisting 的优化。</li><li>shouldRecord、recordModules、recordChunks、recordHash：在 shouldRecord 返回为 true 的情况下，依次触发 recordModules、recordChunks、recordHash。</li><li>reviveModules、beforeModuleIds、moduleIds、optimizeModuleIds、afterOptimizeModuleIds：在生成模块 Id 过程的前后触发。</li><li>reviveChunks、beforeChunkIds、optimizeChunkIds、afterOptimizeChunkIds：在生成 ChunkId 过程的前后触发。</li><li>beforeHash、afterHash：在生成模块与 Chunk 的 hash 过程的前后触发。</li><li>beforeModuleAssets、moduleAsset：在生成模块产物数据过程的前后触发。</li><li>shouldGenerateChunkAssets、beforeChunkAssets、chunkAsset：在创建 Chunk 产物数据过程的前后触发。</li><li>additionalAssets、optimizeChunkAssets、afterOptimizeChunkAssets、optimizeAssets、afterOptimizeAssets：在优化产物过程的前后触发，例如在 TerserPlugin 的压缩代码插件的执行过程中，就用到了 optimizeChunkAssets。</li></ul><p><img src="https://s0.lgstatic.com/i/image/M00/4D/B4/Ciqc1F9bGtqAJo4uAABnYGwsyYs218.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的npm发布流程</title>
      <link href="/post/82c7efc8/"/>
      <url>/post/82c7efc8/</url>
      
        <content type="html"><![CDATA[<p>发布步骤：</p><ol><li>npm init</li><li>npm registry</li><li>npm login</li><li>npm publish</li></ol><h2 id="初始化-npm-init"><a href="#初始化-npm-init" class="headerlink" title="初始化 npm init"></a>初始化 npm init</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>生成的 <em>package.json</em> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;@dotlim/cli&quot;</span>, <span class="comment">// 要发布包的名称 这里的@your-name一定要和author的保持一致</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;tsc --build tsconfig.json&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span>: <span class="string">&quot;^7.14.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span>: <span class="string">&quot;^4.1.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [<span class="string">&quot;lib&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;oxyzhg@163.com&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检测-npm-registry"><a href="#检测-npm-registry" class="headerlink" title="检测 npm registry"></a>检测 npm registry</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>如果不是 npm 镜像源，需要切换回去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry http://registry.npmjs.org</span><br></pre></td></tr></table></figure><p>设置淘宝镜像源的方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="登录-npm-login"><a href="#登录-npm-login" class="headerlink" title="登录 npm login"></a>登录 npm login</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure><h2 id="发布-npm-publish"><a href="#发布-npm-publish" class="headerlink" title="发布 npm publish"></a>发布 npm publish</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果发布的是私有包 通过如下命令开放包</span></span><br><span class="line">npm publish --access public</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端脚手架CLI工具开发实践</title>
      <link href="/post/7852061a/"/>
      <url>/post/7852061a/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要开发-CLI-工具"><a href="#为什么要开发-CLI-工具" class="headerlink" title="为什么要开发 CLI 工具"></a>为什么要开发 CLI 工具</h2><p>我们的项目采用微前端插件化开发，也就是当功能庞大之后，会同时存在多个子项目独立维护。如果某个功能经过重新设计，且前端修改范围已经覆盖了大多数的子应用，这时手动 copy 到处粘贴的方式已经不再是很好的解决方式了，耗时耗力不说，一旦出错排查困难。</p><p>因此我们想到开发一款前端 CLI 工具，初步计划它代替我们完成这些重复性的工作。由于我们的子项目很多时候都是从 0 开始搭建，并且我们有专门的子应用模板用来快速初始化项目，后续我们首先考虑使用脚手架完成初始化新子应用项目的工作。</p><p>接下来的设计将会通过命令的方式解放双手，向前端工程化迈出一步，提效。</p><h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><p>项目设计之初，我们计划通过脚手架实现以下功能：</p><ul><li>初始化项目（init）</li><li>检查更新（upgrade）</li><li>修改本地配置（config）</li></ul><h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>基于以上功能设计，我们将一步步实现代码初始化功能。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>首先，我们初始化一个空项目，目录结构设计如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dotlim-cli</span><br><span class="line">├─ bin</span><br><span class="line">│  └─ www                     // 可执行脚本文件</span><br><span class="line">├─ lib                        // 生产环境可运行代码</span><br><span class="line">├─ src                        // 开发环境可运行代码</span><br><span class="line">│  ├─ command                 // 脚手架命令单独存放</span><br><span class="line">│  ├─ shared                  // 脚手架公共函数库</span><br><span class="line">│  ├─ constants.ts            // 常量</span><br><span class="line">│  └─ main.ts                 // 脚手架入口</span><br><span class="line">├─ .eslintrc</span><br><span class="line">├─ .gitignore</span><br><span class="line">├─ package.json</span><br><span class="line">└─ README.md</span><br></pre></td></tr></table></figure><p>这是我们初步设计的目录结构，其中 <code>/lib</code> 目录是后续用 typescript 重构后，产生的生产环境可执行代码，并且后续还会增加 tsconfig.json 文件等。</p><h3 id="注册命令"><a href="#注册命令" class="headerlink" title="注册命令"></a>注册命令</h3><p>我们定义 <code>dotlim</code> 这个可以在终端运行的脚本命令，即运行 <code>dotlim</code> 命令时，程序会去运行我们配置的 <code>bin/www</code> 脚本文件。其实，根据 npm 的机制，当 install 一个包的时候，会自动去查询其定义的 bin 命令，并将其添加到 <code>node_modules/.bin</code> 文件中去，作为 shell 命令供用户调用执行。因此，如果是局部安装就是局部可用，如果是全局安装就是全局可用的命令。</p><p>在 package.json 添加 bin 字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;bin&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dotlim&quot;</span>: <span class="string">&quot;bin/www&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 bin/www 文件的第一行，一定是第一行，添加 <code>#!/usr/bin/env node</code> 代码，指定脚本的运行环境。【重要】</p><p>接下来，为了方便测试，我们需要将这个包发布到本地的全局环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>注意，<code>npm link</code> 是当我们当前包 link 到本地的全局中，就好比如我们安装依赖时使用了 <code>-g</code> 参数把一些包装到了全局环境一样，是用来方便我们本地开发时测试的，他可以让我们开发的时候自动热更新。如果不清楚 <code>npm link</code> 怎么使用，可以去 npm 官网查查用法再继续往下实践。</p><p>这里需要注意的点：</p><ul><li>首先，最好把你的 npm 的镜像源改为 npm 本身的镜像源（如果你指定了为淘宝等其他的话）；特别是你需要发布 npm 仓库的时候会失败。</li><li>其次，一定要在 <code>package.json</code> 的配置中把 <code>node_modules</code> 等无关的文件夹去掉（或者指定我们需要的），也可以通过 <code>.gitignore</code> 等配置文件忽略掉也可以，或者 <code>.npmrc</code> 等。在哪里设置都可以，因为 npm 配置取值是有一套先后顺序的规则，有兴趣的话可以移步 npm 文档查阅。这里演示一下如何在 <code>package.json</code> 文件的配置：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [<span class="string">&quot;bin&quot;</span>, <span class="string">&quot;lib&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过在 package.json 文件中指定 files 文件夹目录，即告诉 npm 我们实际应该包含的真正文件有哪些，比如我们只需要 <code>bin/src</code> 文件夹，一些默认的文件像 <code>package.json</code> 啊，其他的一些基础配置文件啊，即使你不添加，也会被默认包含进来的。这也是当我们把这个包发布到 <code>npm</code> 所需要配置的，也就是需要哪些文件发布到 npm 仓库上。<strong>再强调一遍，node_modules 一定要排除掉</strong>，不然 npm link 会巨慢而且会失败的概率大，小心踩坑～</p><h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><p>输入我们定义的命令，查看是否可用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotlim      <span class="comment"># 如果脚本执行并输出我们自定义的内容，说明脚本执行成功了</span></span><br></pre></td></tr></table></figure><p>这里注意，一定要给可执行文件第一行添加 <code>#!/usr/bin/env node</code> 代码，否则不可用。</p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>由于代码已通过 typescript 重构，接下来的代码不可避免地会出现一些 ts 相关内容。</p><h3 id="命令行界面的解决方案"><a href="#命令行界面的解决方案" class="headerlink" title="命令行界面的解决方案"></a>命令行界面的解决方案</h3><p>参考网上一些较成熟的设计，我们也采用 <a href="https://www.npmjs.com/package/commander">commander</a> 作为命令行的解决方案。</p><p>在 main.ts 中引入依赖：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> program <span class="keyword">from</span> <span class="string">&#x27;commander&#x27;</span>;</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .name(<span class="string">&#x27;dotlim&#x27;</span>)</span><br><span class="line">  .usage(<span class="string">&#x27;&lt;command&gt; [options]&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-f, --force&#x27;</span>, <span class="string">&#x27;force all the question&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-y, --yes&#x27;</span>, <span class="string">&#x27;run default action&#x27;</span>)</span><br><span class="line">  .version(<span class="built_in">require</span>(<span class="string">&#x27;./package.json&#x27;</span>).version, <span class="string">&#x27;-v, --version&#x27;</span>);</span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure><p>我们给命令行定义了版本信息（version）和帮助指令（help），在命令行中输入 <code>dotlim -v</code>  就可以输出程序的版本信息了，同样的 help 指令也能输出帮助信息。</p><p>以上内容就实现了基本的命令定义与输出功能，接下来我们让脚手架支持初始化项目的能力。</p><h3 id="定义-init-指令"><a href="#定义-init-指令" class="headerlink" title="定义 init 指令"></a>定义 init 指令</h3><p>仍然是声明在刚才的 main.ts 文件中定义指令：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> program <span class="keyword">from</span> <span class="string">&#x27;commander&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateCommand &#125; <span class="keyword">from</span> <span class="string">&#x27;./command/init&#x27;</span>;</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .command(<span class="string">&#x27;init &lt;dir&gt;&#x27;</span>)</span><br><span class="line">  .alias(<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">  .description(<span class="string">&#x27;init a new project with default templates&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-f, --force&#x27;</span>, <span class="string">&#x27;force all the question&#x27;</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">dir, payload</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(dir, payload.options);</span></span><br><span class="line">    <span class="keyword">new</span> CreateCommand(dir, payload);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这帮助我们在程序总注册了 <code>dotlim init &lt;dir&gt;</code>  类似这种形式的指令。关于注册指令的 <code>command</code> , <code>alias</code> , <code>description</code> , <code>action</code>  等方法，大家可以去官网了解下，功能强大，还有更多内容等你去使用。</p><h3 id="设计-CreateCommand-类"><a href="#设计-CreateCommand-类" class="headerlink" title="设计 CreateCommand 类"></a>设计 CreateCommand 类</h3><p>创建 *command/init.ts *文件，我们将要实现的初始化项目功能逻辑几乎都在这里。</p><p>首先，我们设计这里类将要实现的功能。我们希望在命令行中传入将要创建的项目名称，然后从远程拉取代码模板，根据用户填写的配置创建项目，具体步骤如下：</p><ol><li>用户通过命令行输入将要创建的项目名称。</li><li>程序检查用户输入的目录是否存在，如果存在提示是新建、是覆盖、是退出等操作。</li><li>拉取远程仓库的项目代码模板，将其暂存在某个目录。</li><li>将模板文件拷贝到目标文件夹，即用户输入的目录。</li><li>更新 package.json 文件，提示用户输入 name, description, author 等信息，然后将新配置写入文件。</li><li>初始化 Git 仓库，可让用户选择使用全局的 git 配置或新输入配置信息。</li><li>安装项目依赖。</li><li>到这里一切正常的话，提示创建成功，并提示接下来可能的操作指令。</li></ol><p>基于以上设计，我们先实现 CreateCommand Class 的整体设计：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateCommand</span> </span>&#123;</span><br><span class="line">  <span class="attr">source</span>: <span class="built_in">string</span>;</span><br><span class="line">  cmdParams: ParsedParams;</span><br><span class="line">  repoMaps: &#123;</span><br><span class="line">    <span class="attr">target</span>: <span class="built_in">string</span>;</span><br><span class="line">    templatePath: <span class="built_in">string</span>;</span><br><span class="line">    repository: <span class="built_in">string</span>;</span><br><span class="line">    branch: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">projectName: <span class="built_in">string</span>, destination: Cmd, opts = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.source = projectName;</span><br><span class="line">    <span class="built_in">this</span>.cmdParams = parseCmdParams(destination);</span><br><span class="line">    <span class="built_in">this</span>.repoMaps = &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">templatePath</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">repository</span>: <span class="string">&#x27;dotlim-cli&#x27;</span>,</span><br><span class="line">      <span class="attr">branch</span>: <span class="string">&#x27;main&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 按顺序执行程序</span></span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">this</span>.checkFolderExist();</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">this</span>.downloadRepo();</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">this</span>.copyTemplateFields();</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">this</span>.updatePackageJson();</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">this</span>.initGit();</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">this</span>.installDependencies();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      fse.removeSync(<span class="built_in">this</span>.repoMaps.target);</span><br><span class="line">      process.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查目标路径文件是否正确</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">checkFolderExist</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拉取远程仓库的项目模板</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">downloadRepo</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复制模板文件到目标文件夹</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">copyTemplateFields</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新 package.json</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">updatePackageJson</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 Git</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">initGit</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安装项目依赖</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">installDependencies</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上基本就完成了初始化功能的设计，遵循自上而下开发的原则，定义好这些内容，接下来我们就解析各自功能的实现，如果遇到一些内容，在补充到这个 class 中，使其更加健壮。</p><h3 id="检查目标路径文件是否正确"><a href="#检查目标路径文件是否正确" class="headerlink" title="检查目标路径文件是否正确"></a>检查目标路径文件是否正确</h3><p>在检查目录有效性前，我们需要先将用户输入的字符转换为有效的目录地址：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; pluginDirectory &#125; <span class="keyword">from</span> <span class="string">&#x27;../constants&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateCommand</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.repoMaps.templatePath = path.join(pluginDirectory, <span class="built_in">this</span>.repoMaps.repository);</span><br><span class="line">    <span class="built_in">this</span>.repoMaps.target = path.resolve(<span class="built_in">this</span>.source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们提前声明了插件存取的临时文件夹常量（constants.ts），即在用户目录新建一个 <code>.dotlim-cli</code>  的文件夹，在程序中的实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件暂存根目录</span></span><br><span class="line"><span class="keyword">const</span> userdir: <span class="built_in">string</span> = process.env[process.platform === <span class="string">&#x27;darwin&#x27;</span> ? <span class="string">&#x27;HOME&#x27;</span> : <span class="string">&#x27;USERPROFILE&#x27;</span>] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> pluginDirectory: <span class="built_in">string</span> = path.join(userdir, <span class="string">&#x27;.dotlim-cli&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这样就初始化了初始化项目的几个目录变量，以供在这个类的其他方法中共用。</p><p>在程序中，文件相关的操作我们使用 <a href="https://www.npmjs.com/package/fs-extra">fs-extra</a> 库，因为这个库有比 nodejs fs 模块更强大的功能；跟用户的交互操作，比如用户选择或输入某些内容，我们使用 <a href="https://www.npmjs.com/package/inquirer">inquirer</a> 库，这是一个用于 nodejs 环境下进行命令行交互的库，支持单选、多选、用户输入、确认询问等操作，十分强大，更多的使用方式请面向文档学习。</p><p>实现 checkFolderExist 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer <span class="keyword">from</span> <span class="string">&#x27;inquirer&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fse <span class="keyword">from</span> <span class="string">&#x27;fs-extra&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">checkFolderExist</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; target &#125; = <span class="built_in">this</span>.repoMaps;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断用户是否强制覆盖原文件，如果存在</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.cmdParams.force) &#123;</span><br><span class="line">        fse.removeSync(target);</span><br><span class="line">        <span class="keyword">return</span> resolve();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isTarget = fse.pathExistsSync(target);</span><br><span class="line">        <span class="keyword">if</span> (!isTarget) <span class="keyword">return</span> resolve();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; recover &#125; = <span class="keyword">await</span> inquirer.prompt(definedInquirer.recover);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (recover === <span class="string">&#x27;cover&#x27;</span>) &#123;</span><br><span class="line">          fse.removeSync(target);</span><br><span class="line">          <span class="keyword">return</span> resolve();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (recover === <span class="string">&#x27;new&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; rename &#125; = <span class="keyword">await</span> inquirer.prompt(definedInquirer.rename);</span><br><span class="line">          <span class="built_in">this</span>.source = rename;</span><br><span class="line">          <span class="built_in">this</span>.genTargetPath(rename);</span><br><span class="line">          <span class="keyword">await</span> <span class="built_in">this</span>.checkFolderExist();</span><br><span class="line">          <span class="keyword">return</span> resolve();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.red(<span class="string">`[dotlim] <span class="subst">$&#123;err&#125;</span>`</span>));</span><br><span class="line">        process.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是要检查用户指定的目录是否存在，我们首先判断用户是否在选项 option 中执行 <code>-f</code>  强制覆盖功能，如果使用该命令则直接移除原文件后，继续向下执行。如果目标目录存在，我们就在命令行中提示用户操作，操作的定义 <code>definedInquirer</code>  如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> definedInquirer = &#123;</span><br><span class="line">  <span class="attr">recover</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;recover&#x27;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;当前文件夹已存在，请选择操作&#x27;</span>,</span><br><span class="line">      <span class="attr">choices</span>: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;New folder&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;new&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;Cover&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;cover&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;Exit&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;exit&#x27;</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">rename</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;rename&#x27;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;请输入新的项目名称&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，关于检查到目录存在后我们提供了三个选项，分别是：新建、覆盖、退出。如果用户选择新建，那么将提示用户输入新的项目目录名称，然后重新检查重复性。如果用户选择覆盖，那么将移除原目录，然后会在接下来的流程中新建目标目录。</p><h3 id="拉取远程仓库的代码模板"><a href="#拉取远程仓库的代码模板" class="headerlink" title="拉取远程仓库的代码模板"></a>拉取远程仓库的代码模板</h3><p>检查完目录的有效性后，我们就要去远程仓库 github/gitlab 来下载代码模板了。这个操作我们是通过 <a href="https://gitlab.com/flippidippi/download-git-repo">download-git-repo</a> 库实现。这个代码的下载过程可能是漫长的，为了让整个下载的流程有更好的用户体验，我们又使用了 <a href="https://www.npmjs.com/package/ora">ora</a> 库，在命令行中显示加载状态，让用户知道当前程序正在做哪些事，而不是长时间未响应。另外，你可能也注意到了，前面的代码中我们也是有了另外一个库 <a href="https://www.npmjs.com/package/chalk">chalk</a>，他是一款可以让我们的控制台打印出各种颜色/背景的内容的工具，由此我们可以鲜明的区分各种提示内容。</p><p>实现 downloadRepo 功能：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ora <span class="keyword">from</span> <span class="string">&#x27;ora&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">&#x27;chalk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> downloadGitRepo <span class="keyword">from</span> <span class="string">&#x27;download-git-repo&#x27;</span>; <span class="comment">// 在 ts 中提示无类型声明，但不影响使用，暂未解决</span></span><br><span class="line"><span class="keyword">import</span> &#123; promisify &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br><span class="line"><span class="comment">// promisify - 将原回调函数形式Promise化</span></span><br><span class="line"><span class="keyword">const</span> downloadGit = promisify(downloadGitRepo);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> <span class="function"><span class="title">downloadRepo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; repository, branch, templatePath &#125; = <span class="built_in">this</span>.repoMaps;</span><br><span class="line">    <span class="keyword">const</span> remotePath = <span class="string">`github:dotlim/<span class="subst">$&#123;repository&#125;</span>#<span class="subst">$&#123;branch&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> spinner = ora(<span class="string">&#x27;Downloading the project template...&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      spinner.start();</span><br><span class="line">      <span class="comment">// 如果本地临时文件夹存在，则先删除临时文件夹</span></span><br><span class="line">      fse.removeSync(templatePath);</span><br><span class="line">      <span class="keyword">await</span> downloadGit(remotePath, templatePath, &#123; <span class="attr">clone</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      spinner.succeed(<span class="string">&#x27;Successfully downloaded template.&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(chalk.red(<span class="string">`[dotlim] <span class="subst">$&#123;err&#125;</span>`</span>));</span><br><span class="line">      process.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是用来下载远程仓库的代码模板。程序运行后，先检测本地插件定义的模板临时目录是否存在，如果存在删除即可，然后去远程下载最新的代码。这里其实有优化点，就是先检测本地代码和远程仓库的代码版本是否一致，如果一致的话直接跳过就可以了，省去下载代码模板的时间。这里我们友好地呈现了下载过程中的 loading 状态，尽量不让用户焦躁。🤞🤞</p><h3 id="复制模板文件到目标目录"><a href="#复制模板文件到目标目录" class="headerlink" title="复制模板文件到目标目录"></a>复制模板文件到目标目录</h3><p>代码模板下载到临时文件夹后，我们考虑将模板文件拷贝到用户指定的文件夹，然后修修改改就完成了。这里文件拷贝网上有推荐 <a href="https://www.npmjs.com/package/ncp">ncp</a> 库，但前边我们引入了强大的 fs-extra 后，貌似这个库就变得可有可无了，当然如果有需要的话也可以使用下，在我的视线中就直接选了后者。</p><p>实现 copyTemplateFields 功能：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parseCmdParams, copyFiles &#125; <span class="keyword">from</span> <span class="string">&#x27;../shared/utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> <span class="function"><span class="title">copyTemplateFields</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; templatePath, target &#125; = <span class="built_in">this</span>.repoMaps;</span><br><span class="line">    <span class="keyword">const</span> removeFiles = [<span class="string">&#x27;./git&#x27;</span>, <span class="string">&#x27;./changelogs&#x27;</span>, <span class="string">&#x27;README.md&#x27;</span>];</span><br><span class="line">    <span class="keyword">await</span> copyFiles(templatePath, target, removeFiles);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改* shared/utils.ts *文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fse <span class="keyword">from</span> <span class="string">&#x27;fs-extra&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析命令行参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>dest 带解析的命令行参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parseCmdParams</span>(<span class="params">dest: Cmd</span>): <span class="title">ParsedParams</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!dest) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> dest.options.reduce(<span class="function">(<span class="params">ops: ParsedParams, option</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = option.long.slice(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (dest[key] &amp;&amp; !isFunction(dest[key])) ops[key] = dest[key];</span><br><span class="line">    <span class="keyword">return</span> ops;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>source 待拷贝的资源路径（绝对路径）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>target 资源放置路径（绝对路径）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> </span>excludes 需要排除的资源名称（会自动移除其所有子文件）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">copyFiles</span>(<span class="params">source: <span class="built_in">string</span>, target: <span class="built_in">string</span>, excludes: <span class="built_in">string</span>[] = []</span>) </span>&#123;</span><br><span class="line">  fse.copySync(source, target);</span><br><span class="line">  <span class="keyword">if</span> (excludes.length) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(excludes.map(<span class="function">(<span class="params">file</span>) =&gt;</span> <span class="function">() =&gt;</span> fse.removeSync(path.join(target, file))));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，像 copyFiles, parseCmdParams 这样具有通用性的方法，我们统一声明在另外一个文件中，方便在更多的功能中复用。值得注意的是，我们在复制目录的时候，也会移除一些没必要文件或目录。</p><h3 id="更新-package-json"><a href="#更新-package-json" class="headerlink" title="更新 package.json"></a>更新 package.json</h3><p>将模板文件复制到指定目录后，接下来就是修改一些用户指定的项目信息，更新到 package.json 文件。</p><p>实现 updatePackageJson 功能：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; runCmd &#125; <span class="keyword">from</span> <span class="string">&#x27;../shared/utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> <span class="function"><span class="title">updatePackageJson</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> gitPrifiles = <span class="keyword">await</span> <span class="built_in">this</span>.getGitUser();</span><br><span class="line">    <span class="keyword">const</span> &#123; projectName, description, author &#125; = <span class="keyword">await</span> inquirer.prompt(</span><br><span class="line">      definedInquirer.packageJson(<span class="built_in">this</span>.source, gitPrifiles)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> pkgPath = path.resolve(<span class="built_in">this</span>.repoMaps.target, <span class="string">&#x27;package.json&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> spinner = ora(<span class="string">&#x27;Updating package.json...&#x27;</span>);</span><br><span class="line">    spinner.start();</span><br><span class="line">    <span class="comment">// Define the fields to be removed</span></span><br><span class="line">    <span class="keyword">const</span> unnecessaryKeys = [<span class="string">&#x27;keywords&#x27;</span>, <span class="string">&#x27;licence&#x27;</span>, <span class="string">&#x27;files&#x27;</span>];</span><br><span class="line">    <span class="comment">// read package.json</span></span><br><span class="line">    <span class="keyword">const</span> pkgData = fse.readJsonSync(pkgPath);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> unnecessaryKeys) &#123;</span><br><span class="line">      <span class="keyword">delete</span> pkgData[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.assign(pkgData, &#123;</span><br><span class="line">      <span class="attr">name</span>: projectName,</span><br><span class="line">      <span class="attr">description</span>: description,</span><br><span class="line">      <span class="attr">version</span>: <span class="string">&#x27;1.0.0&#x27;</span>,</span><br><span class="line">      <span class="attr">private</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">author</span>: author,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fse.writeJsonSync(pkgPath, pkgData, &#123; <span class="attr">spaces</span>: <span class="number">2</span> &#125;);</span><br><span class="line"></span><br><span class="line">    spinner.succeed(<span class="string">&#x27;Successfully updated package.json&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> getGitUser(): <span class="built_in">Promise</span>&lt;GitUser&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> user = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">email</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [name] = <span class="keyword">await</span> runCmd(<span class="string">&#x27;git config user.name&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> [email] = <span class="keyword">await</span> runCmd(<span class="string">&#x27;git config user.email&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (name) user.name = name.replace(<span class="regexp">/\n/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (email) user.email = email.replace(<span class="regexp">/\n/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.red(<span class="string">`[dotlim] <span class="subst">$&#123;err&#125;</span>`</span>));</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        resolve(user);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 *shared/utils.ts *文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> childProcess <span class="keyword">from</span> <span class="string">&#x27;child_process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行命令</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>cmd 待执行命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runCmd</span>(<span class="params">cmd: <span class="built_in">string</span></span>): <span class="title">Promise</span>&lt;<span class="title">string</span>[]&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    childProcess.exec(cmd, <span class="function">(<span class="params">err, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);</span><br><span class="line">      <span class="keyword">return</span> resolve([stdout, stderr]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先获取了本地全局的 git config 信息，用户生成默认的用户输入提示。nodejs 是通过开启一个子进程来执行脚本命令的，可解析放回的字符得到所需数据，于是 runCmd 我们也封装成公共方法，关于 <a href="http://nodejs.cn/api/child_process.html#child_process_child_process">child_process</a> 更多使用请面向文档学习。</p><p>这里我们同样提供了丰富的用户操作交互，不同的是我们这次的默认值需要动态获取，于是我们使用函数生成了交互数据，具体代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> definedInquirer = &#123;</span><br><span class="line">  <span class="attr">packageJson</span>: <span class="function">(<span class="params">name: <span class="built_in">string</span>, user: GitUser</span>) =&gt;</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;projectName&#x27;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;请输入插件名称&#x27;</span>,</span><br><span class="line">      <span class="attr">default</span>: name,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;请输入插件描述&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;author&#x27;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;请输入插件开发者邮箱&#x27;</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">`<span class="subst">$&#123;user.name&#125;</span> &lt;<span class="subst">$&#123;user.email&#125;</span>&gt;`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的交互中，name, description, author 信息支撑用户重新定义与目录名称不同的字符，也支持直接使用默认值，而 git 相关的数据我们直接通过执行命令获取默认值。</p><h3 id="初始化-Git-仓库"><a href="#初始化-Git-仓库" class="headerlink" title="初始化 Git 仓库"></a>初始化 Git 仓库</h3><p>到这里，项目所有的配置基本就已经生成了。接下来可选初始化 git 仓库，同样的在上面 runCmd 方法的基础上，我们直接执行相关命令，模仿用户手动操作即可。</p><p>实现 initGit 功能：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> <span class="function"><span class="title">initGit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> spinner = ora(<span class="string">&#x27;Initializing git repository...&#x27;</span>);</span><br><span class="line">    spinner.start();</span><br><span class="line">    <span class="keyword">await</span> runCmd(<span class="string">`cd <span class="subst">$&#123;<span class="built_in">this</span>.repoMaps.target&#125;</span>`</span>);</span><br><span class="line">    process.chdir(<span class="built_in">this</span>.repoMaps.target);</span><br><span class="line">    <span class="keyword">await</span> runCmd(<span class="string">`git init`</span>);</span><br><span class="line">    spinner.succeed(<span class="string">&#x27;Successfully initialized the repository.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一点：执行命令的时候，我们首先需要确认当前进程的执行目录是否是目录目录，即新创建的目录，如果不是的话可能会执行报错甚至失败。</p><h3 id="安装项目依赖"><a href="#安装项目依赖" class="headerlink" title="安装项目依赖"></a>安装项目依赖</h3><p>这步也是可选的操作，用于自动安装项目依赖。跟初始化 Git 仓库一样，也需要注意执行目录是否在目标目录，防止报错。</p><p>实现 installDependencies 功能：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> <span class="function"><span class="title">installDependencies</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> spinner = ora(<span class="string">&#x27;Installing CLI plugins. This might take a while...&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      spinner.start();</span><br><span class="line">      <span class="comment">// ensure the execution directory is the target</span></span><br><span class="line">      <span class="keyword">if</span> (path.resolve() !== <span class="built_in">this</span>.repoMaps.target) &#123;</span><br><span class="line">        <span class="keyword">await</span> runCmd(<span class="string">`cd <span class="subst">$&#123;<span class="built_in">this</span>.repoMaps.target&#125;</span>`</span>);</span><br><span class="line">        process.chdir(<span class="built_in">this</span>.repoMaps.target);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// await runCmd(`npm install --registry=http://registry.npm.gridsum.com`);</span></span><br><span class="line">      <span class="keyword">await</span> runCmd(<span class="string">`npm install`</span>);</span><br><span class="line">      <span class="comment">// await runCmd(`git add . &amp;&amp; git commit -m &quot;initial project&quot;`);</span></span><br><span class="line">      spinner.succeed(<span class="string">`Successfully created project <span class="subst">$&#123;<span class="built_in">this</span>.source&#125;</span>.`</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(chalk.red(<span class="string">`[dotlim] <span class="subst">$&#123;err&#125;</span>`</span>));</span><br><span class="line">      process.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上基本就完成了初始化项目的所有功能，至少是经过设计的功能都实现了。当然你可能还有别的想法，也可以在整个过程的设计中增加你想要的步骤，实现更多自定义功能。</p><h2 id="编译-typescript"><a href="#编译-typescript" class="headerlink" title="编译 typescript"></a>编译 typescript</h2><p>我们在开发中使用的编程语言是 typescript，而在 nodejs 环境中并不能直接运行，需要编译成 javascript 语言且模块化方案必须是 commonjs 才能运行，那么我们就配置 tsconfig.json 来实现：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES2016&quot;</span> <span class="comment">/* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNEXT&#x27;. */</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span> <span class="comment">/* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, or &#x27;ESNext&#x27;. */</span>,</span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span>: <span class="literal">true</span> <span class="comment">/* Generates corresponding &#x27;.d.ts&#x27; file. */</span>,</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./lib&quot;</span> <span class="comment">/* Redirect output structure to the directory. */</span>,</span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span>: <span class="literal">true</span> <span class="comment">/* Do not emit comments to output. */</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span> <span class="comment">/* Enable all strict type-checking options. */</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span> <span class="comment">/* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span>,</span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span> <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span> <span class="comment">/* Skip type checking of declaration files. */</span>,</span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span> <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [<span class="string">&quot;src/main.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在开发中，开启 <code>tsc -watch</code>  即可实时将开发中的 typescript 代码编译成 javascript 语言。这里需要注意一点，就是在生产环境发布前，需要手动编译一次，保证 lib 目录下的文件是最新代码。</p><h2 id="后续功能"><a href="#后续功能" class="headerlink" title="后续功能"></a>后续功能</h2><p>实现了项目初始化这个基本功能后，可能后续还会设计/开发其他功能，推动团队前端工程化的进程。前端工程化确实能够有效的提升开发效率，用程序代替开发人员的低效工作，能有效减少人工错误操作带来的问题等，值得在团队中推广。</p><p>相关插件：</p><ul><li><a href="https://www.npmjs.com/package/commander">commander</a></li><li><a href="https://www.npmjs.com/package/inquirer">inquirer</a></li><li><a href="https://www.npmjs.com/package/ora">ora</a></li><li><a href="https://www.npmjs.com/package/chalk">chalk</a></li><li><a href="https://www.npmjs.com/package/fs-extra">fs-extra</a></li><li><a href="https://gitlab.com/flippidippi/download-git-repo">download-git-repo</a></li></ul><hr><p>参考：</p><ul><li><a href="https://juejin.im/post/6847902225025466376">详解前端脚手架开发排坑全指南</a></li><li><a href="https://juejin.cn/post/6844903896163303438">手摸手教你撸一个脚手架</a></li><li><a href="https://github.com/gd4Ark/fa-cli">gd4Ark/fa-cli</a> [typescript]</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端脚手架 </tag>
            
            <tag> cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于lerna管理monorepo项目实践</title>
      <link href="/post/b01c9af0/"/>
      <url>/post/b01c9af0/</url>
      
        <content type="html"><![CDATA[<p>对于维护过多个 package 的同学来说，都会遇到一个选择题，这些 package 是放在一个仓库里维护还是放在多个仓库里单独维护。这里可能会勾起你写微前端项目的那些日子，多个仓库来回折腾。本文通过一个示例讲述了如何基于 Lerna 管理多个 packages，并和其它工具整合，打造高效、完美的工作流，最终形成一个最佳实践。</p><h2 id="monorepo-vs-multirepo"><a href="#monorepo-vs-multirepo" class="headerlink" title="monorepo vs. multirepo"></a>monorepo vs. multirepo</h2><p>Monorepo 的全称是 monolithic repository，即单体式仓库，与之对应的是 Multirepo(multiple repository)，这里的单和多是指每个仓库中所管理的模块数量。</p><p>Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。比如之前的 rollup 插件仓库。</p><p>Monorepo 是把所有相关的 package 都放在一个仓库里进行管理，<strong>每个 package 独立发布</strong>。这个应用的团队就很多了，比如：<a href="https://github.com/facebook/react">react</a>, <a href="https://github.com/rollup/plugins">rollup</a>, <a href="https://github.com/babel/babel">babel</a>, <a href="https://github.com/vuejs/vue-next">vue-next</a>, etc.</p><p>关于 monorepo 与 multirepo 的区别，网上找了张的图：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/116852/1604892216005-85429c34-2173-43e2-8945-cf902fb03ed0.webp#align=left&display=inline&height=720&margin=%5Bobject%20Object%5D&originHeight=720&originWidth=960&size=0&status=done&style=none&width=960"><br>一图胜千言，图中通过对比呈现了两种方案各自的优缺点。我们选择的技术方案有一部分是适配上述特点，所以我们用了。</p><h2 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h2><p>Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。</p><p>Lerna 现在已经被很多著名的项目组织使用，如：Babel, React, Vue, Angular, Ember, Meteor, Jest…</p><p>一个基本的 lerna 管理的仓库结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lerna-repo</span><br><span class="line">├─packages</span><br><span class="line">│  ├─package-a</span><br><span class="line">│  │  ├─src</span><br><span class="line">│  │  └─package.json</span><br><span class="line">│  └─package-b</span><br><span class="line">│     ├─src</span><br><span class="line">│     └─package.json</span><br><span class="line">├─lerna.json</span><br><span class="line">├─package.json</span><br><span class="line">└─README.md</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>推荐全局安装，因为会经常用到 lerna 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lerna -g</span><br></pre></td></tr></table></figure><h3 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h3><p>初始化 lerna 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna init</span><br></pre></td></tr></table></figure><p>执行初始化命令后，会创建 lerna.json 配置文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;packages&quot;</span>: [<span class="string">&quot;packages/*&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 lerna 创建组件和其工具 package：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lerna create mox-table    <span class="comment"># 组件源码</span></span><br><span class="line">lerna create mox-utils    <span class="comment"># 组件复用工具函数，未来可能会有其他工具包</span></span><br></pre></td></tr></table></figure><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>Lerna 在 monorepo 项目中一个非常有价值的地方在于，它能很方便的管理全部 packages 依赖或是某个 package 的依赖。这个方式创建的项目基本配置比 npm init 创建的项目更详细，值得我们使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lerna add lodash                          <span class="comment"># 给所有 packages 添加 lodash 依赖</span></span><br><span class="line">lerna add typescript --scope mox-table    <span class="comment"># 给 mox-table 添加 typescript 依赖</span></span><br><span class="line">lerna add mox-utils --scope mox-table     <span class="comment"># 增加内部模块之间的依赖</span></span><br></pre></td></tr></table></figure><p>这里需要注意的一点是，不管是 yarn workspace 名字还是 lerna scope 的名字，都是 package.json 中的名称，不要跟文件夹名字弄混了。关于 yarn+workspace 后面会详细解释。</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>lerna 提供了十分便利的依赖发布方式，使用 publish 即可完成包括变更版本号在内的所有操作，十分便利。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna publish</span><br></pre></td></tr></table></figure><p>或许你看到这里，才认识到 lerna 存在的意义，但不知如此。</p><h2 id="Lerna-最佳实践"><a href="#Lerna-最佳实践" class="headerlink" title="Lerna 最佳实践"></a>Lerna 最佳实践</h2><p>Lerna 不负责构建，测试等任务，它提出了一种集中管理 package 的目录模式，提供了一套自动化管理程序，让开发者不必再深耕到具体的组件里维护内容，在项目根目录就可以全局掌控，基于 npm scripts，使用者可以很好地完成组件构建，代码格式化等操作。接下来我们就来看看，如果基于 Lerna，并结合其它工具来搭建 Monorepo 项目的最佳实践。</p><p>以下内容暂未在项目中使用，参考网上提供的资料，先整理下来，等项目壮大后再补充。</p><h3 id="优雅的提交"><a href="#优雅的提交" class="headerlink" title="优雅的提交"></a>优雅的提交</h3><p><strong>1.commitizen &amp;&amp; cz-lerna-changelog</strong></p><p>commitizen 是用来格式化 git commit message 的工具，它提供了一种问询式的方式去获取所需的提交信息。<br>cz-lerna-changelog 是专门为 Lerna 项目量身定制的提交规范，在问询的过程，会有类似影响哪些 package 的选择。如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/116852/1604901336647-9050236f-c66c-4c7b-af96-842612eac75c.webp#align=left&display=inline&height=313&margin=%5Bobject%20Object%5D&originHeight=313&originWidth=546&size=0&status=done&style=none&width=546"><br>我们使用 commitizen 和 cz-lerna-changelog 来规范提交，为后面自动生成日志作好准备。</p><p>安装了这两个依赖后，在 package.json 增加 config 字段，把 cz-lerna-changelog 配置给 commitizen。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commit&quot;</span>: <span class="string">&quot;git-cz&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;./node_modules/cz-lerna-changelog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: <span class="string">&quot;^4.2.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cz-lerna-changelog&quot;</span>: <span class="string">&quot;^2.0.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lerna&quot;</span>: <span class="string">&quot;^3.22.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.commitlint &amp;&amp; husky</strong></p><p>上面我们使用了 commitizen 来规范提交，但这个要靠开发自觉使用 npm run commit 。万一忘记了，或者直接使用 git commit 提交怎么办？答案就是在提交时对提交信息进行校验，如果不符合要求就不让提交，并提示。校验的工作由 commitlint 来完成，校验的时机则由 husky 来指定。husky 继承了 Git 下所有的钩子，在触发钩子的时候，husky 可以阻止不合法的 commit,push 等等。</p><h3 id="自动生成日志"><a href="#自动生成日志" class="headerlink" title="自动生成日志"></a>自动生成日志</h3><p>有了之前的规范提交，自动生成日志便水到渠成了。再详细看下 lerna publish 时做了哪些事情：</p><p>1.调用 lerna version</p><ul><li>找出从上一个版本发布以来有过变更的 package</li><li>提示开发者确定要发布的版本号</li><li>将所有更新过的的 package 中的 package.json 的 version 字段更新</li><li>将依赖更新过的 package 的 包中的依赖版本号更新</li><li>更新 lerna.json 中的 version 字段</li><li>提交上述修改，并打一个 tag</li><li>推送到 git 仓库</li></ul><ol start="2"><li>使用 npm publish 将新版本推送到 npm</li></ol><hr><p>参考资料：</p><ul><li><a href="https://juejin.cn/post/6844903911095025678">基于 Lerna 管理 packages 的 Monorepo 项目最佳实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lerna </tag>
            
            <tag> monorepo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给你的项目配置tsconfig.json</title>
      <link href="/post/95d1cb85/"/>
      <url>/post/95d1cb85/</url>
      
        <content type="html"><![CDATA[<p>最近在尝试使用 vue3+typescript+jsx 开发组件时，在配置 <em>tsconfig.json</em> 这一步出现了问题，编译报错、编译不通过，或是编译后的文件不符合预期等。之前写 ts demo 的时候，直接去网上 copy 一份配置就可以了，现在自己要开发项目，显然有些配置是行不通了。那么带着这些问题，我专门查阅了一些关于 typescript 项目基本配置的资料，并整理下来，防止同样的坑掉入两次。</p><p><em>以下示例基于 <a href="mailto:&#116;&#121;&#112;&#101;&#x73;&#x63;&#114;&#105;&#112;&#x74;&#64;&#x34;&#x2e;&#x30;&#46;&#51;">&#116;&#121;&#112;&#101;&#x73;&#x63;&#114;&#105;&#112;&#x74;&#64;&#x34;&#x2e;&#x30;&#46;&#51;</a> 版本。</em></p><h2 id="为什么要使用-tsconfig"><a href="#为什么要使用-tsconfig" class="headerlink" title="为什么要使用 tsconfig"></a>为什么要使用 tsconfig</h2><p>TypeScript 使用 <em>tsconfig.json</em> 文件作为其配置文件，当一个目录中存在 <em>tsconfig.json</em> 文件，则认为该目录是 typescript 项目的根目录。</p><p>通常 tsconfig 主要包含两部分内容：<strong>指定待编译文件</strong>和<strong>定义编译选项</strong>。</p><p>实际上，我们不适用 tsconfig 配置文件，仅通过命令行也可以实现 ts 编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  --outFile // 编译后生成的文件名称</span><br><span class="line">  --target  // 指定ECMAScript目标版本</span><br><span class="line">  --module  // 指定生成哪个模块系统代码</span><br><span class="line">  index.ts  // 源文件</span><br><span class="line">*/</span><br><span class="line">$ npx tsc --outFile index.js --target es5 --module commonjs index.ts</span><br></pre></td></tr></table></figure><p>这段代码就可以实现注释中的功能，但是在实际项目开发中，往往是从整个项目入手，单一的命令行已经不能满足项目开发的需要了，这时就需要 <em>tsconfig.json</em> 配置文件来辅助我们进行代码编译。</p><p>接下来看下 tsconfig 的使用及注意事项。</p><h2 id="初始化配置文件"><a href="#初始化配置文件" class="headerlink" title="初始化配置文件"></a>初始化配置文件</h2><p>安装 typescript 后，我们使用命令生成初始化配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx tsc --init</span><br></pre></td></tr></table></figure><p>这就会为我们自动创建一份较完整的 <em>tsconfig.json</em> 文件，其中的一些配置是通过注释的形式呈现，只需要我们在需要时修改一下配置项即可。生成的默认配置文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Visit https://aka.ms/tsconfig.json to read more about this file */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="comment">// &quot;incremental&quot;: true,                   /* Enable incremental compilation */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span> <span class="comment">/* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNEXT&#x27;. */</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span> <span class="comment">/* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, or &#x27;ESNext&#x27;. */</span>,</span><br><span class="line">    <span class="comment">// &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="comment">// &quot;allowJs&quot;: true,                       /* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="comment">// &quot;checkJs&quot;: true,                       /* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;declaration&quot;: true,                   /* Generates corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;sourceMap&quot;: true,                     /* Generates corresponding &#x27;.map&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;outFile&quot;: &quot;./&quot;,                       /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="comment">// &quot;outDir&quot;: &quot;./&quot;,                        /* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// &quot;composite&quot;: true,                     /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// &quot;tsBuildInfoFile&quot;: &quot;./&quot;,               /* Specify file to store incremental compilation information */</span></span><br><span class="line">    <span class="comment">// &quot;removeComments&quot;: true,                /* Do not emit comments to output. */</span></span><br><span class="line">    <span class="comment">// &quot;noEmit&quot;: true,                        /* Do not emit outputs. */</span></span><br><span class="line">    <span class="comment">// &quot;importHelpers&quot;: true,                 /* Import emit helpers from &#x27;tslib&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in &#x27;for-of&#x27;, spread, and destructuring when targeting &#x27;ES5&#x27; or &#x27;ES3&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to &#x27;ts.transpileModule&#x27;). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span> <span class="comment">/* Enable all strict type-checking options. */</span>,</span><br><span class="line">    <span class="comment">// &quot;noImplicitAny&quot;: true,                 /* Raise error on expressions and declarations with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// &quot;strictBindCallApply&quot;: true,           /* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */</span></span><br><span class="line">    <span class="comment">// &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitThis&quot;: true,                /* Raise error on &#x27;this&#x27; expressions with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// &quot;baseUrl&quot;: &quot;./&quot;,                       /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// &quot;paths&quot;: &#123;&#125;,                           /* A series of entries which re-map imports to lookup locations relative to the &#x27;baseUrl&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span> <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */</span>,</span><br><span class="line">    <span class="comment">// &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */</span></span><br><span class="line">    <span class="comment">// &quot;allowUmdGlobalAccess&quot;: true,          /* Allow accessing UMD globals from modules. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires &#x27;--inlineSourceMap&#x27; or &#x27;--sourceMap&#x27; to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span> <span class="comment">/* Skip type checking of declaration files. */</span>,</span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span> <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在项目目录下直接创建一个 <em>tsconfig.json</em> 文件也未尝不可，但通过命令行创建的配置文件附带了这么多的默认配置选项，还是太香了。</p><p>这时即可通过命令行编译 ts 文件了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx tsc index.ts</span><br></pre></td></tr></table></figure><p>注意，tsc 的命令行选项具有更高的优先级，会覆盖 <em>tsconfig.json</em> 中的同名选项。</p><p>生成的配置项，到底哪些才是适配我们手头的项目呢？接下来我们来看一看。</p><h2 id="解读常用的配置项"><a href="#解读常用的配置项" class="headerlink" title="解读常用的配置项"></a>解读常用的配置项</h2><p>通过查阅 <a href="https://www.typescriptlang.org/tsconfig">TypeScript Reference</a> 文档，结合上述生成的配置项，我们可以总结出主要的两部分配置：</p><ul><li>指定待编译文件： <code>exclude</code> , <code>include</code> , <code>files</code></li><li>定义编译选项： <code>compilerOptions</code></li></ul><p>那么我们就来解读一下这些配置项，已经关键点。</p><h3 id="指定待编译文件"><a href="#指定待编译文件" class="headerlink" title="指定待编译文件"></a>指定待编译文件</h3><p>官方列出的关于指定待编译文件的配置项其实不止这些，但在我们的项目中，这三项更为重要。这些配置可以帮助我们确保 typescript 选择正确的文件进行编译。</p><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>指定要包含在程序中的文件名或特定模式数组，这些文件名是基于 <em>tsconfig.json</em> 的相对地址。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="comment">// &quot;scr&quot;      // 会编译src目录下的所有文件，包括子目录</span></span><br><span class="line">    <span class="comment">// &quot;scr/*&quot;    // 只会编译scr一级目录下的文件</span></span><br><span class="line">    <span class="comment">// &quot;scr/*/*&quot;  // 只会编译scr二级目录下的文件</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常在指定一个目录后，这个目录下的所有 ts 文件都会被编译，即使没有被用到，如果是空文件等不符合要求的文件，或许还会报错。我之前在项目中会配置这个选项，现在由于一些没必要的报错，我更倾向于配置 files 选项。</p><h4 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h4><p>指定在解析 include 时应跳过的文件名或特定模式数组。同样支持 glob 通配符。</p><p>注意这里的默认值是 <code>[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</code>  这些依赖包目录和 <code>compilerOptions.outDir</code>  指定的文件夹。大多数情况下，我们不需要额外配置 exclude 选项，因为这些默认值包含了大多数不需要编译的目录和文件，基本能满足需求。</p><p>跟 include 配置项一样，支持 glob 通配符：</p><ul><li><code>*</code> 匹配 0 或多个字符（不包括目录分隔符）</li><li><code>?</code> 匹配一个任意字符（不包括目录分隔符）</li><li><code>**/</code> 递归匹配任意子目录</li></ul><h4 id="files"><a href="#files" class="headerlink" title="files"></a>files</h4><p>指定需要编译的单个文件列表。通过 import 引入的其他模块的文件也会被编译。</p><p>如果是中小型项目，或不需要使用通配符匹配的项目，可通过这个配置来代替 include 配置项。目前我在封装组件的时候就是配置 files 指定编译程序的入口，然后通过模块关联编译其他文件。</p><p>其他的配置，如 extends, references, typeAcquisition 等一般很少用到，这里就不做过多解释，详情可查文档。</p><h3 id="定义编译选项"><a href="#定义编译选项" class="headerlink" title="定义编译选项"></a>定义编译选项</h3><p>编译选项 <code>compilerOptions</code>  有很多，通常分为以下几类：</p><ul><li>Basic Options</li><li>Strict Type-Checking Options</li><li>Additional Checks</li><li>Module Resolution Options</li><li>Source Map Options</li><li>Experimental Options</li><li>Advanced Options</li></ul><h4 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h4><p>这就是定义编译选项，我们可以根据自己项目的需要，选择合适的配置项。由于配置项较多，这里就挑选几个常用易出错的点进行分析。</p><ul><li>target — 编译后目标语言的版本，目前现代浏览器大多支持 ES6 特性，因此可以选择 ES2015 或更高版本。</li><li>module — 编译后代码的模块类型，可以根据不同的使用场景选择不同的模块化方案。</li><li>lib — 编译需要引入的库，因项目 javascript 版本和编译后使用场景而异，可以查阅各 ECMA 版本对应的库。</li><li>allowJs — 是否允许在你的 ts 文件中引入 js 模块，通常是允许的。</li><li>checkJs — 是否允许校验你的 js 代码并抛出错误，这个看实际情况而定吧。</li><li>jsx — 如果组件是使用 jsx 编写，这决定了输出的代码的组织形式，在 vue+jsx 要使用 preserve.</li><li>declaration — 是否生成 .d.ts 文件。</li><li>outFile — 所有代码输出到一个文件中，这通常是由 webpack/rollup 决定的。</li><li>outDir — 指定编译后文件的输出目录，如果是 npm 包通常配置 lib 文件夹。</li><li>rootDir — 指定文件最长公共路径，用于控制输出目录结构，通常是自动计算，也可以指定某些值。</li><li>incremental — 是否增量编译，可以提升再次编译速度。</li><li>tsBuildInfoFile — 增量编译文件存储位置。</li><li>removeComments — 移除注释，可以根据情况配置，或在 webpack/rollup 中集中处理。</li><li>isolatedModules</li><li>strict — 开启严格类型检查。此项开启后 noImplicitAny, noImplicitThis, strictNullChecks, etc 会默认开启。</li><li>noImplicitAny — 不允许隐式 any 类型。</li><li>noImplicitThis — 不允许 this 是隐式 any 类型，谨慎使用。</li><li>strictNullChecks — 不允许把 null,undefined 赋值给其他类型的变量。</li><li>strictFunctionTypes — 不允许函数参数双向协变。</li><li>strictBindCallApply — 严格的 bind/call/apply 检查。</li><li>strictPropertyInitialization — 类的实例属性必须初始化。</li><li>alwaysStrict — 开启后，编译后的源代码都会注入 <code>&quot;use strict&quot;</code> 。</li><li>noUnusedLocals — 开启后，只声明未使用的变量会报错，默认关闭。</li><li>noUnusedParameters — 开启后，只声明未使用的函数参数会报错，默认关闭。</li><li>noImplicitReturns — 开启后，要求每个函数都要有返回值，默认关闭。</li><li>noFallthroughCasesInSwitch — 开启后，确保每个 switch…case 都必须有 break/return 语句，默认关闭。</li><li>moduleResolution — 指定模块解析策略。</li><li>baseUrl — 解析非相对模块的基地址，默认是当前目录。</li><li>paths — 路径映射，相对于 baseUrl.</li><li>rootDirs — 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化。</li><li>esModuleInterop —</li></ul><p>主要的编译相关的配置已经差不多了，这些足以支撑你完成一个 typescript 项目，剩下还有不少配置没列在这，如果有需要还是查阅<a href="https://www.typescriptlang.org/tsconfig">官方文档</a>为主。</p><h2 id="vue3-ts-项目中的配置"><a href="#vue3-ts-项目中的配置" class="headerlink" title="vue3+ts 项目中的配置"></a>vue3+ts 项目中的配置</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2015&quot;</span> <span class="comment">/* 编译成 ES2015 */</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;es2015&quot;</span> <span class="comment">/* 编译后的代码模块化方案是 ES Module */</span>,</span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span> <span class="comment">/* 允许 javascript 文件编译 */</span>,</span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span> <span class="comment">/* 组件使用 JSX 语法编写，这里采用 vue3 推荐的 preserve */</span>,</span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span>: <span class="literal">true</span> <span class="comment">/* 生成 .d.ts 文件，不过现在还没发现编译后声明文件的作用 */</span>,</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span> <span class="comment">/* 编译后的文件输出到 dist 文件夹 */</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span> <span class="comment">/* 开启严格类型检查，其余的几项也会默认开启 */</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span> <span class="comment">/* 使用 nodejs 提供的模块解析策略 */</span>,</span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span> <span class="comment">/* 兼容 cjs 和 esm 模块化导入导出方案 */</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span> <span class="comment">/* Skip type checking of declaration files. */</span>,</span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span> <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [<span class="string">&quot;src/index.ts&quot;</span> <span class="comment">/* 项目入口文件 */</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是接下来使用 vue3+typescript+jsx 开发组件用例的 <em>tsconfig.json</em> 配置文件，目前仍在探索结合 rollup 的打包方案。</p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> tsconfig.json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rollup+vue3+ts组件打包实践</title>
      <link href="/post/bed04d78/"/>
      <url>/post/bed04d78/</url>
      
        <content type="html"><![CDATA[<p>Vue3 早已发布多时了，更新后一些新特性要利用起来。</p><p>在诸多更新内容中，让我感觉最舒服的点就是 Composition API 的出现，hooks 功能已经能带来很多便利了，甚至我们几乎可以像写 react 那样写 vue3 代码，这看起来是非常有意思的事情。</p><p>为什么说 vue3 越来越 react 化呢，这在开发者看来是编码形式越来越像，尤其在 vue3 的出现，使得 vue 也能像 react 那样使用 hooks 来代替 mixin 这种非主流的方式。当然，尽管我选择使用 jsx 的方式开发 vue3 应用，但我还是认为 vue3 有点不伦不类，因为 Options API 仍然存在，开发者还是逃不掉 vue 帮我们完成一些事，当然这不是坏事。</p><p>每种框架都有其优缺点，看个人喜好选择即可。话不多说，我们动手尝试使用 vue3+typescript+jsx 初始化一个组件小项目，最后我们会使用 rollup 打包这个组件。</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>前些日子看了下别的组件库，有采用 monorepo+lerna 方式管理源码、文档以及其他依赖的方式，正好我们可以学习下这个模式，初始化的项目中包含组件源码和文档源码。</p><p>新建项目目录，并初始化项目：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir test-repo</span><br><span class="line">cd test-repo</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>我们的目录结构应该是这样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">test-repo</span><br><span class="line">├─packages</span><br><span class="line">│  ├─mox-table</span><br><span class="line">│  │  ├─src</span><br><span class="line">│  │  ├─package.json</span><br><span class="line">│  │  └─README.md</span><br><span class="line">│  └─website</span><br><span class="line">│     ├─docs</span><br><span class="line">│     ├─package.json</span><br><span class="line">│     └─README.md</span><br><span class="line">├─.editorconfig</span><br><span class="line">├─.gitignore</span><br><span class="line">├─.prettierrc</span><br><span class="line">├─lerna.json</span><br><span class="line">├─package.json</span><br><span class="line">└─README.md</span><br></pre></td></tr></table></figure><p>这个结构中，test-repo 是包含 mox-table 和 website 两个包的项目，test-repo 本身在 package.json 中设置 <code>private: true</code>  属性保证是私仓不发布，子项目 mox-table 和 website 是需要发布的。这种单仓多包的管理方式大概就是 monorepo 仓储管理方案。</p><h2 id="lerna-workspace"><a href="#lerna-workspace" class="headerlink" title="lerna+workspace"></a>lerna+workspace</h2><p>尽管我们采用 monorepo 的方式来管理这个组件库，但时我们的组件库并没有达到这个量级，这里有点为了用而用的意思，当然也是为了做个尝试，一通二，二通百，触类旁通就是这个道理。</p><p>管理怎么使用 lerna+monorepo 管理单仓多包项目，请看另一篇总结。</p><h2 id="选择静态文档库"><a href="#选择静态文档库" class="headerlink" title="选择静态文档库"></a>选择静态文档库</h2><p>市面上展示静态文档的工具有很多，像 vuepress/gitbook/gatsby/docusaurus 这些都可以作为文档工具使用，本来想选 gatsby 但是本地安装老是出问题，暂时弃用，这里我选用了基于 react 生态的 Docusaurus 展示文档，因为这个比较好看且简洁。</p><p>这里有 <a href="https://www.docusaurus.cn/docs/installation">Docusaurus</a> 官方文档是使用说明，框架很容易上手，这里不作过多赘述。</p><h2 id="组件开发配置"><a href="#组件开发配置" class="headerlink" title="组件开发配置"></a>组件开发配置</h2><p>vue3 项目构建有 webpack 和 vite 可选，由于是本地开发测试项目，我们选择 vite 作为 vue3 的本地构建工具。</p><p>使用 lerna 为 mox-table 包添加依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna add mox-table --scope vue@next vite typescript</span><br></pre></td></tr></table></figure><p>执行 tsc 命令，初始化 tsconfig.json 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx tsc --init</span><br></pre></td></tr></table></figure><p>初始化的配置项有很多，我们根据我们的项目选择适合我们使用的即可，这里关于 tsconfig.json 的总结可以看一下我记录的另一篇笔记，有较全面的说明，这里直接给出一份最终配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2015&quot;</span> <span class="comment">/* 编译成 ES2015 */</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;es2015&quot;</span> <span class="comment">/* 编译后的代码模块化方案是 ES Module */</span>,</span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span> <span class="comment">/* 允许 javascript 文件编译 */</span>,</span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span> <span class="comment">/* 组件使用 JSX 语法编写，这里采用 vue3 推荐的 preserve */</span>,</span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span>: <span class="literal">true</span> <span class="comment">/* 生成 .d.ts 文件，不过现在还没发现编译后声明文件的作用 */</span>,</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span> <span class="comment">/* 编译后的文件输出到 dist 文件夹 */</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span> <span class="comment">/* 开启严格类型检查，其余的几项也会默认开启 */</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span> <span class="comment">/* 使用 nodejs 提供的模块解析策略 */</span>,</span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span> <span class="comment">/* 兼容 cjs 和 esm 模块化导入导出方案 */</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span> <span class="comment">/* Skip type checking of declaration files. */</span>,</span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span> <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [<span class="string">&quot;src/index.ts&quot;</span> <span class="comment">/* 项目入口文件 */</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue 官方也推荐了一份基本配置，由于我们后续还要使用 rollup 打包，因此上述配置已经做了一定的修改。</p><p>我查了下现在社区已经有很多关于 vue3 上手或者原理解析等文章，各有特点，我在学习了一下他们的代码，然后这里给出 jsx 的写法（我比较喜欢 jsx 的写法，一是跟 react 很像，二是引入的其他模块可以不用定义在 data 属性中直接在 render 函数中使用，三是这种开发模式能更好的接近 javascript 开发而不是 vue 大包大揽都帮我们实现）</p><p>最终目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">test-repo</span><br><span class="line">├─packages</span><br><span class="line">│  ├─mox-table</span><br><span class="line">│  │  ├─src</span><br><span class="line">│  │  │  ├─header.tsx</span><br><span class="line">│  │  │  ├─index.ts</span><br><span class="line">│  │  │  ├─interfaces.ts</span><br><span class="line">│  │  │  ├─loading.tsx</span><br><span class="line">│  │  │  └─table.tsx</span><br><span class="line">│  │  ├─examples</span><br><span class="line">│  │  │  ├─App.tsx</span><br><span class="line">│  │  │  └─main.ts</span><br><span class="line">│  │  ├─index.html</span><br><span class="line">│  │  ├─package.json</span><br><span class="line">│  │  ├─README.md</span><br><span class="line">│  │  ├─rollup.config.js</span><br><span class="line">│  │  └─tsconfig.json</span><br><span class="line">│  └─website</span><br><span class="line">│     ├─docs</span><br><span class="line">│     └─package.json</span><br><span class="line">├─lerna.json</span><br><span class="line">├─package.json</span><br><span class="line">└─README.md</span><br></pre></td></tr></table></figure><p>修改 index.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Kala Table&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script type=&quot;module&quot; src=&quot;/test/main.ts&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改 main.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#root&#x27;</span>);</span><br></pre></td></tr></table></figure><p>修改 App.tsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BaseTable &#125; <span class="keyword">from</span> <span class="string">&#x27;../src&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dataSource = [</span><br><span class="line">  &#123; <span class="attr">prov</span>: <span class="string">&#x27;湖北省&#x27;</span>, <span class="attr">confirmed</span>: <span class="number">54406</span>, <span class="attr">cured</span>: <span class="number">4793</span>, <span class="attr">dead</span>: <span class="number">1457</span>, <span class="attr">t</span>: <span class="string">&#x27;2020-02-15 19:52:02&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">prov</span>: <span class="string">&#x27;广东省&#x27;</span>, <span class="attr">confirmed</span>: <span class="number">1294</span>, <span class="attr">cured</span>: <span class="number">409</span>, <span class="attr">dead</span>: <span class="number">2</span>, <span class="attr">t</span>: <span class="string">&#x27;2020-02-15 19:52:02&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">prov</span>: <span class="string">&#x27;河南省&#x27;</span>, <span class="attr">confirmed</span>: <span class="number">1212</span>, <span class="attr">cured</span>: <span class="number">390</span>, <span class="attr">dead</span>: <span class="number">13</span>, <span class="attr">t</span>: <span class="string">&#x27;2020-02-15 19:52:02&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">prov</span>: <span class="string">&#x27;浙江省&#x27;</span>, <span class="attr">confirmed</span>: <span class="number">1162</span>, <span class="attr">cured</span>: <span class="number">428</span>, <span class="attr">dead</span>: <span class="number">0</span>, <span class="attr">t</span>: <span class="string">&#x27;2020-02-15 19:52:02&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">prov</span>: <span class="string">&#x27;湖南省&#x27;</span>, <span class="attr">confirmed</span>: <span class="number">1001</span>, <span class="attr">cured</span>: <span class="number">417</span>, <span class="attr">dead</span>: <span class="number">2</span>, <span class="attr">t</span>: <span class="string">&#x27;2020-02-15 19:52:02&#x27;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> columns = [</span><br><span class="line">  &#123; <span class="attr">code</span>: <span class="string">&#x27;prov&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;省份&#x27;</span>, <span class="attr">width</span>: <span class="number">150</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">code</span>: <span class="string">&#x27;confirmed&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;确诊&#x27;</span>, <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">align</span>: <span class="string">&#x27;right&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">code</span>: <span class="string">&#x27;cured&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;治愈&#x27;</span>, <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">align</span>: <span class="string">&#x27;right&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">code</span>: <span class="string">&#x27;dead&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;死亡&#x27;</span>, <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">align</span>: <span class="string">&#x27;right&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">code</span>: <span class="string">&#x27;t&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;最后更新时间&#x27;</span>, <span class="attr">width</span>: <span class="number">180</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    BaseTable,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">BaseTable</span> <span class="attr">dataSource</span>=<span class="string">&#123;dataSource&#125;</span> <span class="attr">columns</span>=<span class="string">&#123;columns&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">BaseTable</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样一个基本的项目结构就搭建完成了，接下来就是开发组件了，这里还没发开发完，先看下使用 rollup 打包。</p><h2 id="Rollup-打包"><a href="#Rollup-打包" class="headerlink" title="Rollup 打包"></a>Rollup 打包</h2><p>关于 Rollup 打包 vue3+typescript+jsx 项目的配置，也在另一篇笔记中有详细记录，我这里分享最终的 rollup 配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-commonjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-babel&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-typescript2&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-terser&#x27;</span>;</span><br><span class="line"><span class="comment">// import vue from &#x27;rollup-plugin-vue&#x27;;</span></span><br><span class="line"><span class="keyword">import</span> postcss <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-postcss&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> cssnano <span class="keyword">from</span> <span class="string">&#x27;cssnano&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> jsx <span class="keyword">from</span> <span class="string">&#x27;acorn-jsx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> extensions = [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;src/index.ts&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">dir</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&#x27;esm&#x27;</span>,</span><br><span class="line">      <span class="attr">entryFileNames</span>: <span class="string">&#x27;[name].esm.js&#x27;</span>,</span><br><span class="line">      <span class="attr">chunkFileNames</span>: <span class="string">&#x27;chunks/kala-table-[name]-[hash].esm.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">dir</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&#x27;cjs&#x27;</span>,</span><br><span class="line">      <span class="attr">entryFileNames</span>: <span class="string">&#x27;[name].cjs.js&#x27;</span>,</span><br><span class="line">      <span class="attr">chunkFileNames</span>: <span class="string">&#x27;chunks/kala-table-[name]-[hash].cjs.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   dir: &#x27;dist&#x27;,</span></span><br><span class="line">    <span class="comment">//   name: &#x27;Vue&#x27;,</span></span><br><span class="line">    <span class="comment">//   globals: &#123;</span></span><br><span class="line">    <span class="comment">//     vue: &#x27;Vue&#x27;</span></span><br><span class="line">    <span class="comment">//   &#125;,</span></span><br><span class="line">    <span class="comment">//   format: &#x27;umd&#x27;,</span></span><br><span class="line">    <span class="comment">//   entryFileNames: &#x27;[name].umd.js&#x27;,</span></span><br><span class="line">    <span class="comment">//   chunkFileNames: &#x27;chunks/kala-table-[name]-[hash].umd.js&#x27;,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      extensions,</span><br><span class="line">      <span class="attr">mainFields</span>: [<span class="string">&#x27;module&#x27;</span>, <span class="string">&#x27;main&#x27;</span>, <span class="string">&#x27;browser&#x27;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    typescript(&#123;</span><br><span class="line">      <span class="attr">lib</span>: [<span class="string">&#x27;es5&#x27;</span>, <span class="string">&#x27;es6&#x27;</span>, <span class="string">&#x27;dom&#x27;</span>],</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;es5&#x27;</span>,</span><br><span class="line">      <span class="attr">noEmitOnError</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    commonjs(&#123;</span><br><span class="line">      extensions,</span><br><span class="line">      <span class="attr">sourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    babel(&#123;</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&#x27;**/node_modules/**&#x27;</span>,</span><br><span class="line">      <span class="attr">babelHelpers</span>: <span class="string">&#x27;bundled&#x27;</span>,</span><br><span class="line">      extensions,</span><br><span class="line">    &#125;),</span><br><span class="line">    postcss(&#123;</span><br><span class="line">      <span class="attr">plugins</span>: [cssnano],</span><br><span class="line">      <span class="attr">modules</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">extract</span>: path.resolve(<span class="string">&#x27;dist/assets/style.css&#x27;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// vue(&#123;</span></span><br><span class="line">    <span class="comment">//   css: true,</span></span><br><span class="line">    <span class="comment">//   compileTemplate: true,</span></span><br><span class="line">    <span class="comment">// &#125;),</span></span><br><span class="line">    terser(),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">acornInjectPlugins</span>: [jsx()],</span><br><span class="line">  <span class="attr">external</span>: [<span class="string">&#x27;vue&#x27;</span>],</span><br><span class="line">  <span class="attr">treeshake</span>: &#123;</span><br><span class="line">    <span class="attr">moduleSideEffects</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> config;</span><br></pre></td></tr></table></figure><p>上述配置处理了 babel, typescript, jsx, postcss 等相关代码，打包后的文件完全可以在业务组件中引用。</p><p>这篇使用 vue3+typescript+jsx+rollup 开发和打包组件的文章，已经被我拆分为不同的模块了，每个模块基本都有笔记记录开发过程，或许有总结遗漏的地方，</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rollup </tag>
            
            <tag> vue3 </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack打包文件分析</title>
      <link href="/post/5cae23e2/"/>
      <url>/post/5cae23e2/</url>
      
        <content type="html"><![CDATA[<h2 id="Module-amp-webpack"><a href="#Module-amp-webpack" class="headerlink" title="Module &amp; webpack"></a>Module &amp; webpack</h2><p>webpack 本身维护了一套模块系统，这套模块系统兼容了所有前端历史进程下的模块规范，包括 amd/commonjs/es6 等，为了看 module 在 webpack 中是怎么运行的，我们可以看一下下面简单的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./a.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>待编译的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./c&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&#x27;a.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">333</span>;</span><br></pre></td></tr></table></figure><p>打包后的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">      <span class="attr">i</span>: moduleId,</span><br><span class="line">      <span class="attr">l</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">exports</span>: &#123;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(<span class="number">0</span>);</span><br><span class="line">&#125;)([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 引用 模块 1</span></span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__c__ = __webpack_require__(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* harmony default export */</span> __webpack_exports__[<span class="string">&#x27;default&#x27;</span>] = <span class="string">&#x27;a.js&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__c__[<span class="string">&#x27;a&#x27;</span> <span class="comment">/* default */</span>]);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 输出本模块的数据</span></span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="comment">/* harmony default export */</span> __webpack_exports__[<span class="string">&#x27;a&#x27;</span>] = <span class="number">333</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>简化一波代码再看，可以看出打包后实际上是一个立即执行函数，并且入参为各个 module 函数， 最后返回的是 <code>__webpack_require__(0)</code> :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(<span class="number">0</span>); <span class="comment">// 相当于整个程序的入口文件，然后向下找依赖关系</span></span><br><span class="line">&#125;)([module1, module2]);</span><br></pre></td></tr></table></figure><p>我们继续看 <code>__webpack_require__</code>  函数，可以看出它是调用了我们的入口模块，同时传入了 module 相关的属性，以及函数本身：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    <span class="attr">i</span>: moduleId,</span><br><span class="line">    <span class="attr">l</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么继续追溯到入口模块，也就是我们的第一个参数。以下是执行过程：</p><ol><li>我们可以看到入口模块又调用了 <code>webpack_require(1)</code>  去引用入参数组里的第 2 个模块。</li><li>然后会将入参的 webpack_exports 对象添加 default 属性，并赋值。这里我们就能看到模块化的实现原理，这里的 webpack_exports 就是这个模块的 module.exports 通过对象的引用传参，间接的给 module.exports 添加属性。</li><li>最后会将 module.exports return 出来。就完成了 <strong>webpack_require</strong> 函数的使命。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__c__ = __webpack_require__(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* harmony default export */</span> __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (<span class="string">&#x27;a.js&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__c__[<span class="string">&quot;a&quot;</span> <span class="comment">/* default */</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们可以看出 module 其实在 webpack 中，最后的打包结果。</p><h2 id="Module-amp-babel"><a href="#Module-amp-babel" class="headerlink" title="Module &amp; babel"></a>Module &amp; babel</h2><p>虽然 webpack 可以打包转换我们的 module，但通常我们都会引入 babel 来对 ES6 转成 ES5 的代码，而 Moduel 属于 ES6，也会被转译。</p><p>事实上，babel 是将 module 转换成 commonjs，这样 webpack 就无需再做处理，直接使用 webpack 运行时定义的 <strong>webpack_require</strong> 处理。</p><p>不过 babel 在转换的时候，会有一些特殊的处理， 像下面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.default = a;</span><br></pre></td></tr></table></figure><p>首先 export 的时候，会添加一个 __esModule 属性到 exports，是为了表明这是经过转换的 module.</p><p>再看转换输出后的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> d <span class="keyword">from</span> <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"><span class="comment">// 转化后</span></span><br><span class="line"><span class="keyword">var</span> _d = <span class="built_in">require</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> _d2 = _interopRequireDefault(_d);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p><strong>1.为什么有的地方使用 require 去引用一个模块时需要加上 default？</strong></p><p>我们在上文 babel 对导出模块的转换提到，es6 的 export default 都会被转换成 exports.default，即使这个模块只有这一个输出。</p><p><strong>2.经常在各大 UI 组件引用的文档上会看到说明 import { button } from ‘xx-ui’ 这样会引入所有组件内容，需要添加额外的 babel 配置，比如 babel-plugin-component？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="comment">// 转换成</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;element-ui&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> Button = a.Button;</span><br><span class="line"><span class="keyword">var</span> Select = a.Select;</span><br></pre></td></tr></table></figure><p>babel-plugin-component 就做了一件事，将 import { Button, Select } from ‘element-ui’ 转换成了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&#x27;element-ui/lib/button&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Select <span class="keyword">from</span> <span class="string">&#x27;element-ui/lib/select&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>3.我们在浏览一些 npm 下载下来的 UI 组件模块时（比如说 element-ui 的 lib 文件下），看到的都是 webpack 编译好的 js 文件，可以使用 import 或 require 再去引用。但是我们平时编译好的 js 是无法再被其他模块 import 的，这是为什么？</strong></p><p>通过 webpack 模块化原理章节给出的 webpack 配置编译后的 js 是无法被其他模块引用的，webpack 提供了 output.libraryTarget 配置指定构建完的 js 的用途。入口模块返回的 module.exports 赋值给 module.exports.</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rollup基本配置</title>
      <link href="/post/7a834e97/"/>
      <url>/post/7a834e97/</url>
      
        <content type="html"><![CDATA[<h1 id="rollup-基本配置"><a href="#rollup-基本配置" class="headerlink" title="rollup 基本配置"></a>rollup 基本配置</h1><p>rollup 采用 es6 原生的模块机制进行模块的打包构建，rollup 更着眼于未来，对 commonjs 模块机制不提供内置的支持，是一款更轻量的打包工具。rollup 比较适合打包 js 的 sdk 或者封装的框架等，例如，vue 源码就是 rollup 打包的；而 webpack 比较适合打包一些应用，例如 SPA 或者同构项目等等。</p><p>tree shaking 是 rollup 除 es6 模块外的另一个核心卖点，当然这个特性在 webpack 中也有实现。tree-shaking 的优点毋庸多言了，结合 es6 模块，对代码进行静态分析，能更有效地剔除冗余的代码，减小 js 文件的大小。</p><p>基本的 rollup.config.js 配置文件如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;src/main.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">file</span>: <span class="string">&#x27;dist/js/main.min.js&#x27;</span>,</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;bundle&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="输入-input"><a href="#输入-input" class="headerlink" title="输入 input"></a>输入 input</h3><p>**<br>打包的入口点</p><h3 id="文件-output-file"><a href="#文件-output-file" class="headerlink" title="文件 output.file"></a>文件 output.file</h3><p>**<br>要写入的文件</p><h3 id="格式-output-format"><a href="#格式-output-format" class="headerlink" title="格式 output.format"></a>格式 output.format</h3><p>生成包的格式是下列之一：</p><ul><li>amd— 异步模块定义，用于像 RequireJS 这样的模块加载器</li><li>cjs — CommonJS，适用于 Node 和 Browserify/Webpack</li><li>esm — 将软件包保存为 ES 模块文件，在现代浏览器中可以通过 <code>&lt;script type=module&gt;</code> 标签引入</li><li>iife — 一个自动执行的功能，适合作为<code>&lt;script&gt;</code>标签。（如果要为应用程序创建一个捆绑包，您可能想要使用它，因为它会使文件大小变小）</li><li>umd — 通用模块定义，以 <code>amd</code>，<code>cjs</code> 和 <code>iife</code> 为一体</li><li>system — SystemJS 加载器格式</li></ul><h3 id="生成包名称-output-name"><a href="#生成包名称-output-name" class="headerlink" title="生成包名称 output.name"></a>生成包名称 output.name</h3><p><code>String</code> 变量名，代表你的 <code>iife</code>/<code>umd</code> 包，同一页上的其他脚本可以访问它。</p><h3 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件 plugins"></a>插件 plugins</h3><p>插件对象 <code>数组 Array</code> (或一个插件对象)</p><p>常用插件总结：</p><ul><li><a href="https://www.npmjs.com/package/@rollup/plugin-node-resolve">@rollup/plugin-node-resolve</a></li><li><a href="https://www.npmjs.com/package/@rollup/plugin-commonjs">@rollup/plugin-commonjs</a></li><li><a href="https://www.npmjs.com/package/@rollup/plugin-babel">@rollup/plugin-babel</a></li><li><a href="https://www.npmjs.com/package/@rollup/plugin-eslint">@rollup/plugin-eslint</a></li><li><a href="https://www.npmjs.com/package/@rollup/plugin-typescript">@rollup/plugin-typescript</a> (感觉不是很好用)</li><li><a href="https://www.npmjs.com/package/rollup-plugin-typescript2">rollup-plugin-typescript2</a></li><li><a href="https://www.npmjs.com/package/rollup-plugin-terser">rollup-plugin-terser</a></li></ul><p>注意：官方提供的一些包，已经由原单仓单包变更为基于 monorepo 管理的单仓多包的形式，相应的包名称也发生了变化，且原仓库已不再维护，这边建议直接使用新版本依赖包。例如：rollup-plugin-node-resolve 依赖包名称已变更为 @rollup/plugin-node-resolve，具体请查阅 <a href="https://github.com/rollup/plugins">rollup/plugins</a> 官方仓库。</p><h3 id="外链-external"><a href="#外链-external" class="headerlink" title="外链 external"></a>外链 external</h3><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><h3 id="搭配-Babel-7"><a href="#搭配-Babel-7" class="headerlink" title="搭配 Babel 7"></a>搭配 Babel 7</h3><p>rollup 的模块机制是 ES6 Modules，但并不会对 es6 其他的语法进行编译。因此如果要使用 es6 的语法进行开发，还需要使用 babel 来帮助我们将代码编译成 es5。</p><p>使用 @rollup/plugin-babel 插件，同时也需要安装 @babel/core, @babel/preset-env 相关功能依赖包，并且配置 .babelrc 文件，就可以完成上述工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-babel&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    babel(&#123;</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&#x27;node_modules/**&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ESLint-检查"><a href="#ESLint-检查" class="headerlink" title="ESLint 检查"></a>ESLint 检查</h3><p>在代码中使用 linter 无疑是一个很好的决定，尤其是在团队协作开发的项目中，它会强制执行一致的编码规范来帮助我们捕捉一些棘手不易发现的问题。</p><p>这里使用 @rollup/plugin-eslint 插件，在编译过程中检查代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eslint <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-eslint&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    eslint(&#123;</span><br><span class="line">      <span class="attr">exclude</span>: [</span><br><span class="line">        (throwOnError: <span class="literal">true</span>),</span><br><span class="line">        (throwOnWarning: <span class="literal">true</span>),</span><br><span class="line">        (include: [<span class="string">&#x27;src/**&#x27;</span>]),</span><br><span class="line">        (exclude: [<span class="string">&#x27;node_modules/**&#x27;</span>]),</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>eslint 插件有两个属性需要说明：throwOnError 和 throwOnWarning 设置为 true 时，如果在 eslint 的检查过程中发现了 error 或 warning，就会抛出异常，阻止打包继续执行；如果设置为 false，就只会输出 eslint 检测结果，而不会停止打包。</p><h3 id="兼容-CommonJS"><a href="#兼容-CommonJS" class="headerlink" title="兼容 CommonJS"></a>兼容 CommonJS</h3><p>npm 生态已经繁荣了多年，commonjs 规范作为 npm 的包规范，大量的 npm 包都是基于 commonjs 规范来开发的，因此在完美支持 es6 模块规范之前，我们仍旧需要兼容 commonjs 模块规范。</p><p>rollup 官方提供了 @rollup/plugin-commonjs 插件，以便在编译过程中能正常使用 commonjs 依赖包，同时还会搭配 @rollup/plugin-resolve 插件使用，解析模块路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-commonjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">      <span class="attr">mainFields</span>: [<span class="string">&#x27;module&#x27;</span>, <span class="string">&#x27;main&#x27;</span>, <span class="string">&#x27;browser&#x27;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    commonjs(),</span><br><span class="line">    babel(&#123;</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&#x27;node_modules/**&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><p>在生产环境，我们常常需要配置代码压缩功能，这不仅能极大程度减少 bundle 体积大小，也能保护代码。</p><p>压缩代码使用 rollup-plugin-terser 插件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-commonjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-babel&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-terser&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [reoslve(), commonjs(), babel(), terser()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="编译-TypeScript"><a href="#编译-TypeScript" class="headerlink" title="编译 TypeScript"></a>编译 TypeScript</h3><p>现在前端已经有很多程序是使用 typescript 开发，这得益于 ts 优秀的类型检查机制，备受好评。</p><p>使用 rollup-plugin-typescript2 插件（@rollup/plugin-typescript 貌似有点问题），</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-typescript2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    typescript(&#123;</span><br><span class="line">      <span class="attr">lib</span>: [<span class="string">&#x27;es5&#x27;</span>, <span class="string">&#x27;es6&#x27;</span>, <span class="string">&#x27;dom&#x27;</span>],</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;es5&#x27;</span>, <span class="comment">// 输出目标</span></span><br><span class="line">      <span class="attr">noEmitOnError</span>: <span class="literal">true</span>, <span class="comment">// 运行时是否验证ts错误</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="编译-JSX"><a href="#编译-JSX" class="headerlink" title="编译 JSX"></a>编译 JSX</h3><p>基于组件化开发，jsx 无疑是一种很好的开发方式，随着 vue3 发布，不管是 react 还是 vue 都对 jsx 有了很好的支持。vue@next 就是通过 rollup 打包的程序。</p><p>如果是 vue3 开发的程序，还需要配置 babel @vue/babel-plugin-jsx 编译插件。同时，官方推荐 acorn-jsx JSX 解析器将源代码解析到 JSX AST。</p><h3 id="支持-css-预处理器"><a href="#支持-css-预处理器" class="headerlink" title="支持 css 预处理器"></a>支持 css 预处理器</h3><p>现代 web 开发，scss/less/stylus 比纯 css 有更丰富的语法支持，更有利于工程化开发。</p><p>使用 rollup-plugin-postcss 插件，搭配 cssnano 插件可将 Sass/Stylus/Less 文件打包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> postcss <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-postcss&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> cssnano <span class="keyword">from</span> <span class="string">&#x27;cssnano&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    postcss(&#123;</span><br><span class="line">      <span class="attr">plugins</span>: [cssnano],</span><br><span class="line">      <span class="attr">extract</span>: path.resolve(<span class="string">&#x27;dist/assets/style.css&#x27;</span>), <span class="comment">// only for v3</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="rollup-vs-webpack"><a href="#rollup-vs-webpack" class="headerlink" title="rollup vs webpack"></a>rollup vs webpack</h2><p>webpack 诞生的时候，为了解决 css、image 等静态文件的构建和使得代码能够按需加载实现了 code-splitting，在我们日常线上业务代码开发中，或多或少有一些静态资源需要打包，此时 rollup 显得不太适用。所以我们可以看到，在构建一些 lib 的时候可以选择 rollup，而在构建一些应用的时候，选择 webpack 更为合适。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>rollup 的配置是相对简单方便的，我们大概只需要关注项目打包的入口、输出文件、插件使用即可实现 rollup 配置。而 webpack 配置就相对复杂了，这也得益于 webpack 社区多年壮大，产生了较为完善的 webpack 生态。事实情况也是如此，rollup 更像是小众且名声在外的打包工具，适用于一些类库代码的构建，项目体量相对较小，并且更接近现代化前端开发模式，开发者不需要过多考虑代码的兼容性。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rollup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件化在项目中的实践</title>
      <link href="/post/d00fbd96/"/>
      <url>/post/d00fbd96/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>现今的 web 开发通过前后端分离的技术拆分为了 web 后端开发与 web 前端开发，值得指出的是，web 前端开发早已不是传统意义上的开发模式了，转而变成了 web 客户端开发，有过客户端开发经验的同学应该知道这两者间的差别，客户端开发关注的是：</p><ol><li>应用的生命周期</li><li>组件化</li><li>开发模式与打包方法</li></ol><p>组件化是客户端开发最重要的内容，设计一套复用度高、扩展性好的组件系统，可以<strong>显著提高开发效率</strong>，并且可以<strong>减少后期的维护成本</strong>。</p><h2 id="一个笔记组件的案例设计"><a href="#一个笔记组件的案例设计" class="headerlink" title="一个笔记组件的案例设计"></a>一个笔记组件的案例设计</h2><p>就拿我们常用的有道云笔记或语雀等工具为参考，一步步来分析。</p><h3 id="最简-API-设计"><a href="#最简-API-设计" class="headerlink" title="最简 API 设计"></a>最简 API 设计</h3><p>首先，应该为组件取一个恰当的名字，最好能够根据名字知道这个组件的存在意义。这里就叫 Note 吧。不管是在阅读状态还是在编辑状态，该组件都要展示笔记的内容，因为笔记对象应该通过组件的接口传入进来，因为我们为该组件设计第一个 api：</p><table><thead><tr><th>属性</th><th>说明</th><th>类型</th><th>是否必填</th><th>默认值</th></tr></thead><tbody><tr><td>data</td><td>笔记对象</td><td>object</td><td>是</td><td>null</td></tr></tbody></table><p>接下来，我们简单使用一下这个组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> note = &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&#x27;聊聊如何设计组件&#x27;</span>,</span><br><span class="line"> <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Note data=&#123;note&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这样，一个最简 api 的笔记组件就搞定了，它的接口非常简单，只需要提供一个 data 属性，就可以展示出笔记内容，并且可以点击编辑进入书写状态。</p><p>一般而言，如果没有更多的需求的话，我们的笔记组件设计到这里也就可以了。<strong>在设计组件时，务必遵循最小化原则，即尽可能少地抛出接口。</strong>因为使用组件的用户可能有很多，一旦组件作者不小心抛出了一个不合理的接口，以后想要修改就几乎不可能了（只能通过标记过时的方法提醒用户，但这种做法往往是无奈之举）。</p><h3 id="兼容多种数据获取方式"><a href="#兼容多种数据获取方式" class="headerlink" title="兼容多种数据获取方式"></a>兼容多种数据获取方式</h3><p>现在，组件的使用者已经可以通过很简洁的 api 使用这个笔记组件了，但是现在问题来了：有的组件使用者只拿到了笔记的 id，想要通过直接传入 id 的方式使用组件。</p><p>此时，作为组件作者，我们评估了这个需求是合理的，于是，我们扩展了笔记组件的 api：</p><table><thead><tr><th>属性</th><th>说明</th><th>类型</th><th>是否必填</th><th>默认值</th></tr></thead><tbody><tr><td>data</td><td>笔记对象</td><td>object</td><td>否</td><td>null</td></tr><tr><td>dataId</td><td>笔记对象 ID</td><td>object</td><td>否</td><td>null</td></tr></tbody></table><p>现在可以通过传入 id 的方式来使用组件了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> noteId = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&lt;Note dataId=&#123;noteId&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这是组件设计的一个技巧，通过支持多种数据源使得调用更加简单。但是这种设计也有其弊端所在，如果这种兼容性的扩展过多会使得组件的内部逻辑变得复杂，也会使得 api 变得难于理解，因此，<strong>对于兼容性的 api 扩展要谨慎，不可过量</strong>。</p><h3 id="兼容不同模式"><a href="#兼容不同模式" class="headerlink" title="兼容不同模式"></a>兼容不同模式</h3><p>组件的使用一如既往的优雅、简单，但是现在又有用户提出新的需求了：因为该组件是支持阅读与编辑两种模式的，在使用时，对于他人的笔记是不可编辑的，能否在指定的场景下只支持一种阅读模式？</p><p>笔记组件由于内部支持了两种模式，既支持阅读，也支持编辑。因此调用者只想使用一种模式也是合理的。于是，我们继续扩展组件的 api：</p><table><thead><tr><th>属性</th><th>说明</th><th>类型</th><th>是否必填</th><th>默认值</th></tr></thead><tbody><tr><td>mode</td><td>模式，数组的第一项作为初始模式，该参数不可为空数组</td><td>array</td><td>否</td><td><code>[&#39;write&#39;, &#39;read&#39;]</code></td></tr></tbody></table><p>现在，对于只想使用阅读模式的用户，可以这么调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> note = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> mode = [<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">&lt;Note data=&#123;note&#125; mode=&#123;mode&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在设计 api 时，我们在满足需求的前提下，支持了更多情况。首先，使用者也可能只使用编辑模式，因为 mode 参数是支持随意组合各种模式的，因此这种情况也能满足。另外，如果组件以后扩展了更多模式，该 api 仍然能满足需求，只需要为 mode 数组增加更多的模式项即可。这里有一个更佳的设计是，当使用多个模式时，确定哪个模式作为初始模式也是有必要的，因此，将 mode 数组的第一项作为多模式下的初始模式，既满足了需求，又达到了 api 设计最小化的原则。</p><p>现在，我们对用户的需求进行了扩展，不仅支持只使用阅读模式，还支持各种模式任意组合和初始模式，但是这还不够，组件的设计者应当针对需求想到更长远的情况，针对这个例子，我们还可以为组件扩展一个模式改变的事件，让调用者可以捕捉到笔记组件从阅读 -&gt; 编辑或编辑 -&gt; 阅读（随着模式的扩展，这种组合会更多）切换的时机：</p><table><thead><tr><th>事件</th><th>说明</th><th>回调参数</th></tr></thead><tbody><tr><td>modeChange</td><td>模式切换时触发</td><td>(from: string, to: string) from 表示切换前的模式，to 表示切换后的模式</td></tr></tbody></table><p>调用者可能在捕捉到模式切换事件时，做一些特定的工作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleModeChange = <span class="function">(<span class="params"><span class="keyword">from</span>, to</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Note</span> <span class="attr">onModeChange</span>=<span class="string">&#123;handleModeChange&#125;</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><h3 id="更多的支持"><a href="#更多的支持" class="headerlink" title="更多的支持"></a>更多的支持</h3><p>除了扩展组件的能力外，我们还可以扩展组件的视图。比如笔记的工具栏，我们可以通过 api 拓展而渲染出来，这就是组件的<strong>子视图设计</strong>，在 web 前端的组件化中，称为<strong>插槽</strong>。我们可以为笔记组件扩展一个工具栏的插槽：</p><table><thead><tr><th>插槽</th><th>说明</th><th>参数</th></tr></thead><tbody><tr><td>toolbar</td><td>工具栏子视图</td><td>{ data }</td></tr></tbody></table><h2 id="如何设计组件"><a href="#如何设计组件" class="headerlink" title="如何设计组件"></a>如何设计组件</h2><p>上述案例讲述了组件设计的整个流程，通过分析用户的需求（或未来可能出现的需求），一步一步地设计出了一个复用度高、扩展性好的组件。如果你是一个组件设计的新手，你应该如何去思考、去设计一个优良的组件呢？</p><h3 id="1-先设计，后实现"><a href="#1-先设计，后实现" class="headerlink" title="1. 先设计，后实现"></a>1. 先设计，后实现</h3><p>我们通篇在讨论组件的设计，但是实际操作时，很多朋友会通过边实现边设计的方式来完成一个组件的制作，这是不合理的，因为自身能力与眼界的限制，实现可能会干扰你的设计，对于以下两个经典矛盾，希望读者能选择后者，以追求合理性为重。</p><ol><li>这样实现比较方便，不如将这个参数抛出让用户传进来吧！</li><li>这样设计比较合理，虽然实现难度可能会比较高，但我可以通过文档学习、求问他人的方式来实现它，或者直接让他人来实现。</li></ol><p><strong>提出问题比解决问题更难。</strong>设计难于实现，你应当花 70%的时间来设计而不是用来实现。有的设计者甚至不参与实现，设计者与实现者的身份也是随时在转换的，善于思考的实现者本身就是设计者。</p><h3 id="2-组件设计四要素"><a href="#2-组件设计四要素" class="headerlink" title="2. 组件设计四要素"></a>2. 组件设计四要素</h3><ol><li>属性</li><li>方法</li><li>事件</li><li>子视图</li></ol><p>上述的案例基本涵盖了这四个要素，这四要素共同组成了组件的 API。需要注意的，除了基本的四要素外，我们还需要注意这些也是组件 API 的一部分：</p><ul><li>属性的类型、是否必填、默认值（属性类型确定后不再变化）</li><li>方法的参数、返回值（需要考虑变化的情况）</li><li>事件回调函数的参数</li><li>插槽可获取到的局部参数</li></ul><p>在设计时，应当小心谨慎面对每一个 api 的要素，哪一个环节出现了设计缺陷，对于调用者都是如鲠在喉。</p><h2 id="终极思维：面向对象"><a href="#终极思维：面向对象" class="headerlink" title="终极思维：面向对象"></a>终极思维：面向对象</h2><p>尽管我们通过一系列的理论讲述了组件设计的方法，但是对于初学者而言，仍然难以设计出一个优良的组件，设计一个优良的组件需要大量的经验，初学者往往考虑不全面，或因对需求的不了解，无法预知未来的变化。</p><p>尽管如此，初学者仍然要耐心学习组件的设计，不积跬步无以至千里，经过一段时间的积累，我总结了一个设计组件的终极思维，将面向对象的思想用于组件设计，将会事半功倍。</p><p>在开发领域，学会思考比埋头干活重要。我们将这个理论用于组件设计中，如何通过面向对象的思维来设计一个组件呢？</p><p>虽然我们强调使用面向对象的思维来设计组件，但仿佛面向对象思维比组件设计更高深，我们当然不会推荐大家用更加晦涩的理论来指导组件的设计，这里，我们将面向对象拟人化，提取出一个自然世界联想法的思维方法。</p><p>下面我们就用这种方法，来设计一个快递小哥的组件：</p><ul><li>首先，快递小哥有他的基本信息，这是该组件的<strong>属性</strong>，基本信息中包含了他的任职单位、工作年限、姓名、联系方式等等。</li><li>此外，快递小哥有一些特有的行为，例如送快递、接收包裹等，我们可以将这部分抽取为组件的<strong>方法</strong>，比如我们调用快递小哥的接收包裹方法，该方法有两个参数，第一个参数是我要寄的东西即包裹，第二个参数是快递单，描述了寄送相关的信息。</li><li>除了基本信息和一些行为外，快递小哥组件还有一些特有的<strong>事件</strong>，当我们的包裹到了时，他会打电话给我们，这里，组件抛出了一个快递到达的事件，事件的参数是快递单和包裹，快递单描述了包裹的送达信息，包裹是快递单中描述的接收人的东西。</li><li>最后，快递小哥组件有没有<strong>子视图</strong>呢？有。快递小哥组件除了被我们普通用户调用外，还会被快递公司所调用，不同的快递公司会以不同的方式来包装快递小哥（例如通过不同服装不同 logo 的方式），因此，快递公司在调用该组件时，会将快递小哥的服装传入一个名为装束的子视图中，这样，不同公司的快递小哥就有不同的装束了。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>重新回到开篇的问题，为什么说当今的 web 前端开发已变成 web 客户端开发呢？因为组件化是所有客户端开发的核心概念，只要这个端大部分的时间在做组件抽象的工作，我们就可以认为自己在从事客户端开发。<br>最后，组件化不是银弹，不能为你解决任何实际问题，它只是一种思维方式。</p><hr><p>相关资料：</p><ul><li><a href="https://juejin.im/post/6878099828497186823">如何制作一个组件？论组件化思想</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 组件化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从vue源码解读nextTick</title>
      <link href="/post/bf1c5ae8/"/>
      <url>/post/bf1c5ae8/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 执行是单线程的，它是基于事件循环。事件循环大致分为以下几步：</p><ol><li>所有任务都在主线程上，形成一个执行栈</li><li>主线程之外，还存在一个任务队列。只要在任务队列有了结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕，就会读取任务队列，看看有哪些事件。哪些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上述步骤。</li></ol><p>主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。 消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。</p><p>在浏览器环境中，常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate；常见的 micro task 有 MutationObsever 和 Promise.then。</p><p>先看 nextTick 源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = [];</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">  callbacks.length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timerFunc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop);</span><br><span class="line">  &#125;;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  !isIE &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp;</span><br><span class="line">  (isNative(MutationObserver) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks);</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter));</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter);</span><br><span class="line">  &#125;;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve;</span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    timerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码量很少，首先 nextTick 函数接受一个函数，并把这个函数缓存起来，最后等任务队列进如宏任务队列时，取出一次执行。这里的 timerFunc 是根据不同的环境采用不同的兼容方案，依次是 <code>Promise.then</code> , <code>MutationObserver</code> , <code>setImmediate</code> , <code>setTimeout</code> ，等进如异步任务队列后，通过 flushCallbacks 执行所有缓存的函数。</p><p>总结：nextTick 通过同步任务，将待执行的函数缓存到数组中，并开启一个异步任务，等所有同步任务执行完成，异步任务的回调会取出所有缓存的函数执行。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 源码 </tag>
            
            <tag> nextTick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地开发构建效率优化</title>
      <link href="/post/9e86daf9/"/>
      <url>/post/9e86daf9/</url>
      
        <content type="html"><![CDATA[<h2 id="提取公共库"><a href="#提取公共库" class="headerlink" title="提取公共库"></a>提取公共库</h2><p>vue 开发过程中，保存一次就会编译一次，如果能够减少编译的时间，哪怕是一丁点，也能节省不少时间。开发过程中个人编写的源文件才会频繁变动，而一些库文件一般我们不会去改动。如果能把库文件提取出来，就能达到减少打包体积，加快编译速度。</p><p>这里尝试使用 <strong>DllPlugin</strong>/<strong>DllReferencePlugin</strong> 通过提取公共库，来解决这个问题。</p><p>1、新建 webpack.dll.config.js 配置文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webapck = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dllPath = <span class="string">&#x27;public/vendor&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 这里只用于开发环境</span></span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">vendor</span>: [</span><br><span class="line">      <span class="string">&#x27;vue&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vue-router&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vuex&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;axios&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;lodash-es&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;@gs-ui/gs-ui&#x27;</span>,</span><br><span class="line">      <span class="comment">// &#x27;@components/page-layout&#x27;,</span></span><br><span class="line">      <span class="comment">// &#x27;@moebius/confirm&#x27;,</span></span><br><span class="line">      <span class="comment">// &#x27;@moebius/modal&#x27;,</span></span><br><span class="line">      <span class="comment">// &#x27;vue-fullscreen&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, dllPath), <span class="comment">// 打包后文件的输出位置</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].dll.js&#x27;</span>, <span class="comment">// 生成的文件名字 默认为vendor.dll.js</span></span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]_library&#x27;</span>, <span class="comment">// 生成文件的映射关系，与下面的 DllPlugin 配置相对应</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 清除之前的dll文件</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> webapck.DllPlugin(&#123;</span><br><span class="line">      <span class="attr">path</span>: path.join(__dirname, dllPath, <span class="string">&#x27;[name]-manifest.json&#x27;</span>),</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]_library&#x27;</span>, <span class="comment">// 与 output.library 中的配置对应</span></span><br><span class="line">      <span class="attr">context</span>: process.cwd(), <span class="comment">// 上下文环境路径，必须填写，为了与DLLReferencePlugin存在于同一上下文中，否则undefined</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、添加生成 dll 文件的 npm 脚本命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dll&quot;</span>: <span class="string">&quot;webpack -p --progress --config webpack.dll.config.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、忽略已编译的文件<br>为了节约编译的时间，这时间我们需要告诉 webpack 公共库文件已经编译好了，减少 webpack 对公共库的编译时间。修改 vue.config.js 相关配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isProductionEnv = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 仅在开发环境中启用</span></span><br><span class="line">    <span class="keyword">if</span> (!isProductionEnv) &#123;</span><br><span class="line">      config.plugins.push(</span><br><span class="line">        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">          <span class="attr">context</span>: process.cwd(),</span><br><span class="line">          <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&#x27;./public/vendor/vendor-manifest.json&#x27;</span>),</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4、加载生成的 dll 文件：<br>经过上面的配置，公共库提取出来了，编译速度也快了，但如果不引用生成的 dll 文件，网页还是会因为缺少相关代码而不能正常运行，因此需要我们手动引入之前打包过的 dll 文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vendor/vendor.dll.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>补充：发现有插件可以自动添加到 html 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 仅在开发环境中启用</span></span><br><span class="line">    <span class="keyword">if</span> (!isProductionEnv) &#123;</span><br><span class="line">      <span class="comment">// 使用已编译好的代码</span></span><br><span class="line">      config.plugins.push(</span><br><span class="line">        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">          <span class="attr">context</span>: process.cwd(),</span><br><span class="line">          <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&#x27;./public/vendor/vendor-manifest.json&#x27;</span>),</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将dll文件自动注入到html</span></span><br><span class="line">      config.plugins.push(</span><br><span class="line">        <span class="keyword">new</span> AddAssetHtmlPlugin(&#123;</span><br><span class="line">          <span class="attr">filepath</span>: resolve(<span class="string">&#x27;public/vendor/*.js&#x27;</span>),</span><br><span class="line">          <span class="attr">publicPath</span>: <span class="string">&#x27;./vendor&#x27;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;./vendor&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> 本地开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router钩子函数及解析流程</title>
      <link href="/post/bcbf126b/"/>
      <url>/post/bcbf126b/</url>
      
        <content type="html"><![CDATA[<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>钩子函数的种类有：全局守卫、路由守卫、组件守卫</p><p>全局守卫：</p><ul><li>beforeEach</li><li>beforeResolve</li><li>afterEach</li></ul><p>路由独享的守卫：</p><ul><li>beforeEnter</li></ul><p>组件内的守卫：</p><ul><li>beforeRouteEnter</li><li>beforeRouteUpdate</li><li>afterRouteLeave</li></ul><h2 id="导航解析流程"><a href="#导航解析流程" class="headerlink" title="导航解析流程"></a>导航解析流程</h2><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree-shaking</title>
      <link href="/post/a762c08d/"/>
      <url>/post/a762c08d/</url>
      
        <content type="html"><![CDATA[<p>当前端项目达到一定规模后，我们一般会采用按模块方式组织代码，这样可以方便代码的组织及维护。但会存在一个问题，比如我引入一个 utils 工具类，这会在打包的时候将 utils 中不必要的代码也打包，从而使得打包体积变大，这时候就需要用到 tree-shaking 技术了。</p><p>国内外许多资料，都会将 tree-shaking 的最佳解释指向了 <a href="https://webpack.js.org/guides/tree-shaking/">webpack tree-shaking</a>，实际上，webpack 文档是非常值得我们阅读与学习的，并且也是现代前端打包非常好的实践。</p><p>简单描述：Tree shaking 是一种通过<strong>清除上下文未引用代码</strong>(dead-code)方式来优化项目打包体积的技术。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>它依赖于 ES2015 模块语法的 <a href="http://exploringjs.com/es6/ch_modules.html#static-module-structure">静态结构</a> 特性：</p><ul><li>只能作为模块顶层的语句出现</li><li><code>import</code> 的模块名只能是字符串变量，不能动态引入模块</li><li><code>import binding</code> 是 <code>immutable</code> 的，引入的模块不能在进行修改</li></ul><p>在 ES6 模块出现后 tree-shaking 才被利用起来，因为 tree-shaking 只能在静态 modules 下工作。ESM 加载是静态的，因此整个依赖树可以被静态的推导出解析语法树。tree-shaking 不仅支持 <code>import/export</code> 级别，也支持 statement 级别。</p><p>在 ESM 出现之前，我们可以使用 CommonJS 引入模块：<code>require</code> 。这种引入是动态的，也意味着可以基于条件来导入需要的代码，这种模块导入的不确定性，意味着 tree-shaking 不适用。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在 webpack4 中，通过 <code>package.json</code> 的 <code>sideEffects</code> 属性作为标记，向 <code>compiler</code> 提供判断条件，表示项目中的哪些问价那是 <code>pure</code> ，由此可以安全的删除文件中未使用的部分。</p><p>webpack4 之后的版本，只需要设置 <code>mode:production</code> 即可开启 tree-shaking.</p><p>如果你的代码确实有一些副作用，可以改为提供一个数组：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;your-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sideEffects&quot;</span>: [<span class="string">&quot;./src/some-side-effectful-file.js&quot;</span>, <span class="string">&quot;*.css&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：所有导入文件都会受到 tree-shaking 的影响。这意味着，如果在项目中使用类似 css-loader 并 import 一个 CSS 文件，则需要将其添加到 sideEffects 列表中，以免在生产模式中无意中将它删除。</p><h2 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h2><p>sideEffects 指那些当 import 的时候会执行一些动作，但是不一定会有任何 export，比如 polyfill 不暴露方法给主程序使用。</p><p>tree-shaking 不能自动的识别哪些代码属于 sideEffects，因此需要手动指定这些代码，如果不指定会出现意想不到的问题。</p><p>在 webpack4 中，是通过配置 sideEffects 属性来实现的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sideEffects&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有代码都不包含副作用，那么可以简单的设置 false 即可，如果存在有副作用的代码，那么可以提供一个数组：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sideEffects&quot;</span>: [<span class="string">&quot;./src/common/polyfill.js&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>tree-shaking 利用了  ESM  的静态导入特性，不支持动态导入。</li><li>webpack4 可以在项目 <code>package.json</code> 设置 <code>sideEffects</code> 属性，手动指定副作用脚本。</li><li>rollup 天生支持 tree-shaking.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rollup </tag>
            
            <tag> webpack </tag>
            
            <tag> TreeShaking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读vue源码不可不知的代码片段</title>
      <link href="/post/c2ee5191/"/>
      <url>/post/c2ee5191/</url>
      
        <content type="html"><![CDATA[<p>初读 vue(v2.6.11) 源码，尝试理清一些功能的实现原理，发现有不少代码片段同时涉及许多重要的功能，对理解 vue 原理及功能实现产生重要影响。本文在整理过程中记录、梳理这些代码片段，以供自己对 vue 源码进行拆解理解，掌握不同功能之间的关联，从而形成相对完整的 vue 知识体系。</p><p>下面的源码会标记源码文件的路径，帮助理解这段代码是在哪个模块实现、跟哪些模块有关联；并把相关源码贴在这，然后简要概括这段代码的主要作用，便于理解。读者只需将其中的一些源码串联起来，基本就能解释很多 vue 功能的原理，带来很清晰的思路，也是换一种方式阅读和梳理源码。</p><h3 id="定义-Vue-构造函数"><a href="#定义-Vue-构造函数" class="headerlink" title="定义 Vue 构造函数"></a>定义 Vue 构造函数</h3><p>源码：<em>src/core/instance/index.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue);</span><br><span class="line">stateMixin(Vue);</span><br><span class="line">eventsMixin(Vue);</span><br><span class="line">lifecycleMixin(Vue);</span><br><span class="line">renderMixin(Vue);</span><br></pre></td></tr></table></figure><h3 id="initMixin"><a href="#initMixin" class="headerlink" title="initMixin"></a>initMixin</h3><p>源码：<em>src/core/instance/init.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm._uid = uid++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag;</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span>;</span><br><span class="line">      endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span>;</span><br><span class="line">      mark(startTag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm._isVue = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      initInternalComponent(vm, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      initProxy(vm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm._renderProxy = vm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm;</span><br><span class="line">    initLifecycle(vm);</span><br><span class="line">    initEvents(vm);</span><br><span class="line">    initRender(vm);</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">    initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    initState(vm);</span><br><span class="line">    initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;created&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>);</span><br><span class="line">      mark(endTag);</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化主要就干了几件事情：合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 <code>data</code>、 <code>props</code>、 <code>computed</code>、 <code>watcher</code> 等。</p><h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h3><p>源码：<em>src/core/instance/state.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = [];</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options;</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props);</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods);</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe((vm._data = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed);</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>wathcer</code> 等属性做了初始化操作。</p><h3 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h3><p>源码：<em>src/core/instance/state.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data;</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ? getData(data, vm) : data || &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&#x27;data functions should return an object:\n&#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props;</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods;</span><br><span class="line">  <span class="keyword">let</span> i = keys.length;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i];</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(<span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>, vm);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">            <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化主要完成两件事：一个是对定义 <code>data</code> 函数返回对象的遍历，通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上；另一个是调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式。</p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>源码：<em>src/core/instance/state.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: noop,</span><br><span class="line">  <span class="attr">set</span>: noop,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">target: <span class="built_in">Object</span>, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key];</span><br><span class="line">  &#125;;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>Object.defineProperty</code> 把 <code>target[sourceKey][key]</code> 的读写变成了对 <code>target[key]</code> 的读写。</p><h3 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h3><p>源码：<em>src/core/observer/index.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment"> * returns the new observer if successfully observed,</span></span><br><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span>;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用是给非 VNode 的对象类型数据添加一个 <code>Observer</code>，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例。</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>源码：<em>src/core/observer/index.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that is attached to each observed</span></span><br><span class="line"><span class="comment"> * object. Once attached, the observer converts the target</span></span><br><span class="line"><span class="comment"> * object&#x27;s property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="attr">value</span>: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value: any</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through all properties and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params">obj: <span class="built_in">Object</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">observeArray</span>(<span class="params">items: <span class="built_in">Array</span>&lt;any&gt;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这才是真正实现响应式的逻辑。先实例化 <code>Dep</code> 对象，接着通过执行 <code>def</code> 函数把自身实例添加到数据对象 <code>value</code> 的 <code>__ob__</code> 属性上，接下来会对 <code>value</code> 做判断，对于数组会调用 <code>observeArray</code> 方法，否则对纯对象调用 <code>walk</code> 方法。可以看到 <code>observeArray</code> 是遍历数组再次调用 <code>observe</code> 方法，而 <code>walk</code> 方法是遍历对象的 key 调用 <code>defineReactive</code> 方法。</p><h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h3><p>源码：<em>src/core/observer/index.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  obj: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: string,</span></span></span><br><span class="line"><span class="params"><span class="function">  val: any,</span></span></span><br><span class="line"><span class="params"><span class="function">  customSetter?: ?<span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  shallow?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set;</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend();</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 <code>Dep</code>  对象的实例，接着拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法，这样就保证了无论 <code>obj</code> 的结构多复杂，它的所有子属性也能变成响应式的对象，最后利用 <code>Object.defineProperty</code> 去给 <code>obj</code> 的属性 <code>key</code> 添加 getter 和 setter。这样就通过定义 getter 和 setter 拦截器，在对数据进行读写的时候执行<strong>依赖收集</strong>和<strong>派发更新</strong>，形成一个响应式对象。</p><h3 id="arrayMethods"><a href="#arrayMethods" class="headerlink" title="arrayMethods"></a>arrayMethods</h3><p>源码：<em>src/core/observer/array.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted);</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先继承 <code>Array</code> ，然后对数组的 7 个方法（能改变原数组）进行重写。重写后的方法先执行原方法的逻辑，然后对能增加数组长度的方法进行拦截，把新增值变成响应式数据，最后手动触发依赖通知。<br>也就是说，同过修改数组下标和数组长度等未拦截的方法，不能实现响应式拦截。</p><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>源码：<em>src/core/observer/dep.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++;</span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addSub</span>(<span class="params">sub: Watcher</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">removeSub</span>(<span class="params">sub: Watcher</span>)</span> &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice();</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// This is globally unique because only one watcher</span></span><br><span class="line"><span class="comment">// can be evaluated at a time.</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> targetStack = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  targetStack.push(target);</span><br><span class="line">  Dep.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  targetStack.pop();</span><br><span class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Dep</code>  是整个 getter 依赖收集的核心，它实际上就是对 <code>Watcher</code> 的一种管理，脱离 <code>Watcher</code> 单独存在是没有意义的。<br><code>Dep</code>  有一个静态属性 <code>target</code>，这是一个全局唯一 <code>Watcher</code>，因为在同一时间只能有一个全局的 <code>Watcher</code> 被计算，另外它的自身属性 <code>subs</code> 也是 <code>Watcher</code> 的数组。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>源码：<em>src/core/observer/watcher.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A watcher parses an expression, collects dependencies,</span></span><br><span class="line"><span class="comment"> * and fires callback when the expression value changes.</span></span><br><span class="line"><span class="comment"> * This is used for both the $watch() api and directives.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="attr">vm</span>: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: <span class="built_in">Function</span>;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?<span class="built_in">Function</span>;</span><br><span class="line">  getter: <span class="built_in">Function</span>;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">    expOrFn: string | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    cb: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    options?: ?<span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    isRenderWatcher?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep;</span><br><span class="line">      <span class="built_in">this</span>.user = !!options.user;</span><br><span class="line">      <span class="built_in">this</span>.lazy = !!options.lazy;</span><br><span class="line">      <span class="built_in">this</span>.sync = !!options.sync;</span><br><span class="line">      <span class="built_in">this</span>.before = options.before;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = <span class="built_in">this</span>.user = <span class="built_in">this</span>.lazy = <span class="built_in">this</span>.sync = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.id = ++uid; <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="built_in">this</span>.lazy; <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="built_in">this</span>.deps = [];</span><br><span class="line">    <span class="built_in">this</span>.newDeps = [];</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="built_in">this</span>.expression = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> ? expOrFn.toString() : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.getter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = noop;</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">              <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">              <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">            vm</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy ? <span class="literal">undefined</span> : <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">        traverse(value);</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget();</span><br><span class="line">      <span class="built_in">this</span>.cleanupDeps();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">addDep</span>(<span class="params">dep: Dep</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.newDepIds.add(id);</span><br><span class="line">      <span class="built_in">this</span>.newDeps.push(dep);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">cleanupDeps</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="built_in">this</span>.deps[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="built_in">this</span>.depIds;</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="built_in">this</span>.newDepIds;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = tmp;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds.clear();</span><br><span class="line">    tmp = <span class="built_in">this</span>.deps;</span><br><span class="line">    <span class="built_in">this</span>.deps = <span class="built_in">this</span>.newDeps;</span><br><span class="line">    <span class="built_in">this</span>.newDeps = tmp;</span><br><span class="line">    <span class="built_in">this</span>.newDeps.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Subscriber interface.</span></span><br><span class="line"><span class="comment">   * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">      <span class="built_in">this</span>.dirty = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">      <span class="built_in">this</span>.run();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">this</span>.get();</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="built_in">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="built_in">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="built_in">this</span>.vm, <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the value of the watcher.</span></span><br><span class="line"><span class="comment">   * This only gets called for lazy watchers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">evaluate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deps[i].depend();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove self from all dependencies&#x27; subscriber list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">teardown</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">      <span class="comment">// remove self from vm&#x27;s watcher list</span></span><br><span class="line">      <span class="comment">// this is a somewhat expensive operation so we skip it</span></span><br><span class="line">      <span class="comment">// if the vm is being destroyed.</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(<span class="built_in">this</span>.vm._watchers, <span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length;</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="built_in">this</span>.deps[i].removeSub(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.active = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Watcher</code>  定义了一些和 <code>Dep</code>  相关的属性： <code>deps</code> , <code>newDeps</code> , <code>depIds</code> , <code>newDepIds</code> ，和一些方法： <code>addDep</code> , <code>cleanupDeps</code> …这个地方相对难理解，重点关注 <code>get</code> , <code>addDep</code> , <code>cleanupDeps</code> , <code>update</code> , <code>run</code>  这几个实例方法。（需要更新）<br>触发更新后，不管同步更新还是异步更新，最终会执行 <code>run</code>  方法。这里调用 <code>get</code>  方法触发 getter 视图更新。</p><h3 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h3><p>源码：<em>src/core/observer/scheduler.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with duplicate IDs will be skipped unless it&#x27;s</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id;</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引入了一个队列的概念，这也是 Vue 在做派发更新的时候的一个优化的点，它并不会每次数据改变都触发 <code>watcher</code> 的回调，而是把这些 <code>watcher</code> 先添加到一个队列里，然后在 <code>nextTick</code> 后执行 <code>flushSchedulerQueue</code>。</p><h3 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h3><p>源码：<em>src/core/observer/scheduler.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush both queues and run the watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow();</span><br><span class="line">  flushing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> watcher, id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component&#x27;s user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component&#x27;s watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index];</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before();</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id;</span><br><span class="line">    has[id] = <span class="literal">null</span>;</span><br><span class="line">    watcher.run();</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;You may have an infinite update loop &#x27;</span> +</span><br><span class="line">            (watcher.user</span><br><span class="line">              ? <span class="string">`in watcher with expression &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span>),</span><br><span class="line">          watcher.vm</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line">  <span class="keyword">const</span> activatedQueue = activatedChildren.slice();</span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice();</span><br><span class="line"></span><br><span class="line">  resetSchedulerState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call component updated and activated hooks</span></span><br><span class="line">  callActivatedHooks(activatedQueue);</span><br><span class="line">  callUpdatedHooks(updatedQueue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">&#x27;flush&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列排序：</p><ul><li>组件的更新由父到子；因为父组件的创建过程是先于子的，所以 <code>watcher</code> 的创建也是先父后子，执行顺序也应该保持先父后子。</li><li>用户的自定义 <code>watcher</code> 要优先于渲染 <code>watcher</code> 执行；因为用户自定义 <code>watcher</code> 是在渲染 <code>watcher</code> 之前创建的。</li><li>如果一个组件在父组件的 <code>watcher</code> 执行期间被销毁，那么它对应的 <code>watcher</code> 执行都可以被跳过，所以父组件的 <code>watcher</code> 应该先执行。</li></ul><p>队列排序：</p><ul><li>在对 <code>queue</code> 排序后，接着就是要对它做遍历，拿到对应的 <code>watcher</code>，执行 <code>watcher.run()</code>。</li><li>这里需要注意一个细节，在遍历的时候每次都会对 <code>queue.length</code> 求值，因为在 <code>watcher.run()</code> 的时候，很可能用户会再次添加新的 <code>watcher</code>，这样会再次执行到 <code>queueWatcher</code>。</li></ul><p>执行 run 方法，先同 get 获取数据，触发视图更新。</p><h3 id="mountComonent"><a href="#mountComonent" class="headerlink" title="mountComonent"></a>mountComonent</h3><p>源码：<em>src/core/instance/lifecycle.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm: Component, el: ?Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el;</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) ||</span><br><span class="line">        vm.$options.el ||</span><br><span class="line">        el</span><br><span class="line">      ) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(<span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>, vm);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm._name;</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid;</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">      mark(startTag);</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render();</span><br><span class="line">      mark(endTag);</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag);</span><br><span class="line"></span><br><span class="line">      mark(startTag);</span><br><span class="line">      vm._update(vnode, hydrating);</span><br><span class="line">      mark(endTag);</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(</span><br><span class="line">    vm,</span><br><span class="line">    updateComponent,</span><br><span class="line">    noop,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">before</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">          callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">  );</span><br><span class="line">  hydrating = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span>;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行 <code>vm._render()</code>  渲染 vnode 之前，触发了 <code>beforeMount</code>  生命周期钩子；在执行完 <code>vm._update()</code>  把 vnode patch 到真实 DOM 后，触发了 <code>mounted</code>  生命周期钩子。<br>而这个函数的核心是实例化一个渲染 <code>Watcher</code> ，在它的回调函数中调用 <code>updateComponent</code>  方法，在此方法中先调用 <code>vm._render</code>  生成 vnode，在调用 <code>vm._update</code>  更新 DOM。 <code>Watcher</code>  在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的检测数据发生变化执行回调函数，触发更新。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式原理</title>
      <link href="/post/c8b44329/"/>
      <url>/post/c8b44329/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是响应式"><a href="#什么是响应式" class="headerlink" title="什么是响应式"></a>什么是响应式</h2><p>响应式是指数据模型发生变化后，视图会进行同步更新。</p><h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><p>实例在初始化阶段会执行 initState 初始化组件状态，同时执行 initProps, initData 进行响应式数据定义（<a href="/post/c2ee5191/#Observer">observe</a> 劫持数据，<strong>劫持就意味着有更多操作空间</strong>），这里是定义响应式数据的逻辑。</p><p>Observer 对于数组和对象类型的数据有不同的处理方式：</p><ul><li>对于<a href="/post/c2ee5191/#arrayMethods">数组类型</a>的数据，实际拦截的是 7 种实例方法(push, pop, shift, unshift, splice, sort, reverse)，它们特点是都具备 sideEffect，能够改变原数组，如果其中某个操作新增数组，那么就会对新增数据定义响应式。</li><li>对于<a href="/post/c2ee5191/#defineReactive">对象类型</a>的数据，使用 <code>Object.defineProperty</code> 拦截 getter/setter 操作，分别进行依赖收集和派发更新。这是整个响应式的核心之一。</li></ul><p><strong>响应式过程分两步：依赖收集和派发更新</strong>。</p><h2 id="如何进行依赖收集"><a href="#如何进行依赖收集" class="headerlink" title="如何进行依赖收集"></a>如何进行依赖收集</h2><p>依赖收集实际上就是收集使用当前数据的 Watcher, 并且 Dep 与 Watcher 是双向收集。</p><p>当某个 Watcher 使用了响应式数据模型，这个过程会触发 getter，然后依次通过 <code>dep.depend</code> -&gt; <code>watcher.addDep</code> -&gt; <code>dep.addSub</code> 三个步骤，使得 Watcher 收集到<strong>数据发布者</strong>，Dep 收集到<strong>数据订阅者</strong>。</p><p>更新全局 <code>Dep.target</code> 的操作发生在 <code>watcher.get</code> 被调用时，也就是某个 Watcher 执行会就将当前监听器置于 targetStack 栈顶。换句话说，全局的 <code>Dep.target</code> 就是初始化时正在使用响应式数据模型的 Watcher，就在这里触发了 getter，并进行依赖收集。</p><h2 id="如何触发视图更新"><a href="#如何触发视图更新" class="headerlink" title="如何触发视图更新"></a>如何触发视图更新</h2><p>派发更新就是通知收集的数据订阅者执行更新的过程。</p><p>当响应式数据模型发生了变化，这个过程会触发 setter，然后依次通过 <code>dep.notify</code> -&gt; <code>watcher.update</code> 等步骤，更新视图。这个过程非常复杂，暂时不安排解读。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>追踪变化：通过劫持数据来追踪变化，在 vue2 中使用 <code>Object.defineProperty</code> 拦截，在 vue3 中使用 <code>Proxy</code> 拦截。</li><li>依赖收集：定义响应式数据后，若监听器使用该数据便触发 getter，然后 Watcher 收集数据发布者，Dep 收集数据订阅者。</li><li>派发更新：当数据模型发生变化，即触发 setter，然后数据发布者 Dep 会通知数据收集者 Watcher，执行 <code>watcher.update</code> 进行更新。</li></ol><p>Vue 官方提供的响应式原理图：<img src="https://cn.vuejs.org/images/data.png" alt="响应式原理"></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html">深入响应式原理</a></li><li><a href="https://juejin.cn/post/6857669921166491662">图解 Vue 响应式原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 响应式原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从vue源码解读生命周期</title>
      <link href="/post/5f595b09/"/>
      <url>/post/5f595b09/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载 DOM 实例、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。</p></blockquote><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><ol><li><strong>beforeCreate</strong></li><li><strong>created</strong></li><li><strong>beforeMount</strong></li><li><strong>mounted</strong></li><li><strong>beforeUpdate</strong></li><li><strong>updated</strong></li><li>activated</li><li>deactivated</li><li><strong>beforeDestroy</strong></li><li><strong>destroyed</strong></li><li>errorCaptured</li></ol><h2 id="从源码看实例生命周期"><a href="#从源码看实例生命周期" class="headerlink" title="从源码看实例生命周期"></a>从源码看实例生命周期</h2><p>源码中最终执行生命周期的函数都是调用 callHook 方法，它的定义在 <em>src/core/instance/lifecycle.js</em> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">callHook</span>(<span class="params">vm: Component, hook: string</span>) </span>&#123;</span><br><span class="line">  pushTarget();</span><br><span class="line">  <span class="keyword">const</span> handlers = vm.$options[hook];</span><br><span class="line">  <span class="keyword">const</span> info = <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span>;</span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(handlers[i], vm, <span class="literal">null</span>, vm, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(<span class="string">&#x27;hook:&#x27;</span> + hook);</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="beforeCreate-amp-created"><a href="#beforeCreate-amp-created" class="headerlink" title="beforeCreate &amp; created"></a>beforeCreate &amp; created</h3><p>beforeCreate 和 created 函数都是在实例化阶段触发，在 <code>_init</code>  方法中执行的，它的定义在 <em>src/core/instance/init.js</em> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initLifecycle(vm);</span><br><span class="line">  initEvents(vm);</span><br><span class="line">  initRender(vm);</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">  initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  initState(vm);</span><br><span class="line">  initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  callHook(vm, <span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到 beforeCreate 和 created 的钩子调用是在 initState 的前后，initState 的作用是初始化 props, data, methods, watch, computed 等属性。显然 beforeCreate 的钩子中不能获取到 props, data 中定义的值，也不能调用 methods 中定义的函数。</p><p>在执行两个钩子函数的时候，并没有渲染 DOM，所以我们也不能访问 DOM，一般来说，如果组件在加载的时候需要和后端有交互，放在这俩个钩子函数执行都可以，如果是需要访问 props、data 等数据的话，就需要使用 created 钩子函数。</p><h3 id="beforeMount-amp-mounted"><a href="#beforeMount-amp-mounted" class="headerlink" title="beforeMount &amp; mounted"></a>beforeMount &amp; mounted</h3><p>beforeMount 钩子函数在 DOM 挂载前触发，在 mountComponent 函数中执行，定义在 <em>src/core/instance/lifecycle.js</em> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm: Component, el: ?Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm._name;</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid;</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">      mark(startTag);</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render();</span><br><span class="line">      mark(endTag);</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag);</span><br><span class="line"></span><br><span class="line">      mark(startTag);</span><br><span class="line">      vm._update(vnode, hydrating);</span><br><span class="line">      mark(endTag);</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(</span><br><span class="line">    vm,</span><br><span class="line">    updateComponent,</span><br><span class="line">    noop,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">before</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">          callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">  );</span><br><span class="line">  hydrating = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span>;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行 <code>vm._render()</code>  函数渲染 VNode 之前，执行了 beforeMount 钩子函数，执行完后把 VNode push 到真实 DOM 后，执行了 mounted 钩子。注意代码注释中提到，这是手动挂载实例的执行逻辑，真正的组件初始化过程，是执行 invokeInsertHook  函数，定义在 <em>src/core/vdom/patch.js</em> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeInsertHook</span>(<span class="params">vnode, queue, initial</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// delay insert hooks for component root nodes, invoke them after the</span></span><br><span class="line">  <span class="comment">// element is really inserted</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(initial) &amp;&amp; isDef(vnode.parent)) &#123;</span><br><span class="line">    vnode.parent.data.pendingInsert = queue;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; ++i) &#123;</span><br><span class="line">      queue[i].data.hook.insert(queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert 函数定义在 <em>src/core/vdom/create-component.js</em> 中的 componentVNodeHooks 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">vnode: MountedComponentVNode</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode;</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">      componentInstance._isMounted = <span class="literal">true</span>;</span><br><span class="line">      callHook(componentInstance, <span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个子组件都是在这个钩子函数中执行 mounted 钩子函数。并且之前我们分析过，insertedVNodeQueue 的添加顺序是先父后子，所以对于同步渲染的子组件而言，mounted 钩子的执行顺序也是先父后子。</p><h3 id="beforeUpdate-amp-updated"><a href="#beforeUpdate-amp-updated" class="headerlink" title="beforeUpdate &amp; updated"></a>beforeUpdate &amp; updated</h3><p>beforeUpdate 钩子函数是在实例数据放生变化 更新 DOM 前触发，定义在监听器的 before 函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm: Component, el: ?Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(</span><br><span class="line">    vm,</span><br><span class="line">    updateComponent,</span><br><span class="line">    noop,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">before</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">          callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个钩子函数要在实例挂载完成后才会触发。</p><p>updated 钩子函数的执行时机在 flushSchedulerQueue 函数调用时，它定义在 <em>src/core/observer/scheduler.js</em> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 获取到 updatedQueue</span></span><br><span class="line">  callUpdatedHooks(updatedQueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callUpdatedHooks</span>(<span class="params">queue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = queue.length;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = queue[i];</span><br><span class="line">    <span class="keyword">const</span> vm = watcher.vm;</span><br><span class="line">    <span class="keyword">if</span> (vm._watcher === watcher &amp;&amp; vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">&#x27;updated&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 updatedQueue 是已更新的数组， callUpdatedHooks 函数会遍历这个数组，满足条件的会触发 updated 钩子函数。</p><p>之前提到过，在组件实例化过程中，会实例化一个渲染的 Watcher 去监听 vm 上的数据变化重新渲染，在实例化 Watcher 过程中会判断 isRenderWatcher，若是则会把当前 watcher 实例赋值给 <code>vm._watcher</code>，Watcher 类定义在 <em>src/core/observer/watcher.js</em> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">    expOrFn: string | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    cb: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    options?: ?<span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    isRenderWatcher?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是渲染相关的 watcher 实例才赋值给 <code>vm._watcher</code> 属性，因此在 callUpdatedHook 函数中，触发 updated 钩子函数前又作了一层判断，只有 <code>vm._watcher</code> 等于当前 watcher 实例，即当前是渲染相关 watcher 实例，才会执行 updated 钩子函数。</p><h3 id="beforeDestroy-amp-destroyed"><a href="#beforeDestroy-amp-destroyed" class="headerlink" title="beforeDestroy &amp; destroyed"></a>beforeDestroy &amp; destroyed</h3><p>beforeDestroy 和 destroyed 钩子函数都在是组件销毁阶段触发，通过调用 <code>$destroy</code> 方法执行。方法在组件实例化过程中，执行 lifecycleMixin 函数时定义，它的定义在 <em>src/core/instance/lifecycle.js</em> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lifecycleMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (vm._isBeingDestroyed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeDestroy&#x27;</span>);</span><br><span class="line">    vm._isBeingDestroyed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// remove self from parent</span></span><br><span class="line">    <span class="keyword">const</span> parent = vm.$parent;</span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123;</span><br><span class="line">      remove(parent.$children, vm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// teardown watchers</span></span><br><span class="line">    <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">      vm._watcher.teardown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = vm._watchers.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      vm._watchers[i].teardown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// remove reference from data ob</span></span><br><span class="line">    <span class="comment">// frozen object may not have observer.</span></span><br><span class="line">    <span class="keyword">if</span> (vm._data.__ob__) &#123;</span><br><span class="line">      vm._data.__ob__.vmCount--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// call the last hook...</span></span><br><span class="line">    vm._isDestroyed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// invoke destroy hooks on current rendered tree</span></span><br><span class="line">    vm.__patch__(vm._vnode, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// fire destroyed hook</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;destroyed&#x27;</span>);</span><br><span class="line">    <span class="comment">// turn off all instance listeners.</span></span><br><span class="line">    vm.$off();</span><br><span class="line">    <span class="comment">// remove __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release circular reference (#6759)</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode) &#123;</span><br><span class="line">      vm.$vnode.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>beforeDestroy 钩子函数的执行时机是在实例销毁前，接着执行了一些销毁动作，包括从父实例移除自身，删除 watcher，当前渲染的 VNode 执行销毁钩子函数等，待执行完毕触发 destroyed 钩子函数。</p><p>注意这里在执行完 <code>vm._patch(vm_vnode, null)</code>  后，先触发了 destroyed 钩子函数，然后才执行 <code>vm.$off()</code>  移除所有监听器，因此在 destroyed 阶段仍可访问组件实例。</p><h3 id="activated-amp-deactivated"><a href="#activated-amp-deactivated" class="headerlink" title="activated &amp; deactivated"></a>activated &amp; deactivated</h3><p>这两个生命周期钩子是 keep-alive 内置组件专门定制的。</p><h2 id="父子组件生命周期函数执行顺序"><a href="#父子组件生命周期函数执行顺序" class="headerlink" title="父子组件生命周期函数执行顺序"></a>父子组件生命周期函数执行顺序</h2><p>加载渲染过程：</p><ol><li>父 beforeCreate</li><li>父 created</li><li>父 beforeMount</li><li>子 beforeCreate</li><li>子 created</li><li>子 beforeMount</li><li>子 mounted</li><li>父 mounted</li></ol><p>更新过程：</p><ol><li>父 beforeUpdate</li><li>子 beforeUpdate</li><li>子 updated</li><li>父 updated</li></ol><p>销毁过程：</p><ol><li>父 beforeDestroy</li><li>子 beforeDestroy</li><li>子 destroyed</li><li>父 destroyed</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>组件的生命周期大致分为 4 个阶段，分别是：create、mount、update、destroy，每个阶段的始末又分为 2 个钩子，主要的生命周期钩子就是由这 8 个组成。</p><p>在组件实例化的过程中，会执行一系列的初始化方法，这其中有 intMixin, StateMixin, eventsMixin, lifecycleMixin, renderMixin 等。</p><p>在 initMixin 方法中会注入 <code>Vue.prototype._init</code> 方法，而在初始化阶段会被直接调用，这个函数中主要逻辑除了执行配置合并等操作，在 beforeCreate 钩子触发前会执行 initLifecycle, initEvents, initRender 步骤，在 created 钩子触发前会执行 initInjections, initState, initProvide 步骤。</p><p>在 lifecycleMixin 方法中会注入 <code>Vue.prototype._update</code>, <code>Vue.prototype.$forceUpdate</code>, <code>Vue.prototype.$destroy</code> 方法，其中在组件销毁阶段会直接调用 $destroy 函数。</p><p>在 web/runtime 相关代码中，又给 Vue 增加了 $mount 公共函数，该函数返回 mountComponent 函数的执行结果。在 mountComponent 函数中触发了 beforeMount 钩子函数，并且实例化 Watcher 监听器，该监听器配置了数据发生改变后 before 钩子，用来触发 beforeUpdate 钩子函数。等元素插入 DOM 结构中(vdom/patch.js)，调用 insert 函数触发 mounted 钩子函数。注意这里的渲染顺序仍然是先子后父。</p><p>当监听到实例的数据发生变化后，会触发监听器 watcher 的 before 钩子触发 beforeUpdate 钩子函数。在 flushSchedulerQueue 函数中，更新队列执行完成后，会触发 updated 钩子函数。</p><p>在组件预先定义的生命周期中，执行 $destroy 函数先触发 beforeDestroy 钩子函数，等组件实例销毁、删除数据监听、并从 DOM 结构中移除，触发 destroy 钩子函数。</p><p>官方资料：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></li><li><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">选项/生命周期钩子</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 源码 </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端模块化</title>
      <link href="/post/2b2f44ba/"/>
      <url>/post/2b2f44ba/</url>
      
        <content type="html"><![CDATA[<p>前端模块化方案在近几年层出不穷，有基于 NodeJS 的 CommonJS，也有属于客户端的 AMD/CMD 等。随着 ECMA 的不断迭代，javascript 在语言层面出现了 ES Module 的模块化方案，模块化正在朝着统一的方向进行。</p><h2 id="什么是模块化？"><a href="#什么是模块化？" class="headerlink" title="什么是模块化？"></a>什么是模块化？</h2><p>是指<strong>将复杂的系统分解成多个独立模块</strong>的代码组织方式。</p><h2 id="常见的模块化方案有哪些"><a href="#常见的模块化方案有哪些" class="headerlink" title="常见的模块化方案有哪些"></a>常见的模块化方案有哪些</h2><ul><li>AMD (Asynchronous Module Definition)，即异步模块定义。（RequireJS）</li><li>CMD (Common Module Definition)，即通用模块定义。（SeaJS）</li><li>CommonJS</li></ul><p>随着 webpack/rollup/babel 等打包或编译工具在前端大放异彩，AMD/CMD 也在逐渐退出历史舞台。说起来，从我学习 javascript 起，几乎很少直接接触到这两种模块化方案，大多是在打包工具的输出文件中见到。</p><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>Require.js 用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&#x27;js/lib&#x27;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="attr">jquery</span>: <span class="string">&#x27;jquery.min&#x27;</span>, <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="attr">underscore</span>: <span class="string">&#x27;underscore.min&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;underscore&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$, _</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>AMD 特点：</p><ol><li>是<strong>依赖前置</strong>，在定义模块的时候就要声明其依赖模块。</li><li>是<strong>异步加载</strong>其他模块，在客户端运行的代码，需要从服务端预先加载，因此异步加载是更合理的方案。</li></ol><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>Sea.js 用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** math.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">exports</span>.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&#x27;math.js&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>CMD 特点：</p><ol><li>是<strong>就近依赖</strong>，只有在用到某个模块的时候再去加载。</li></ol><p>AMD/CMD 的区别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line">define([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, d, e, f</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">    b.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CMD写法 **/</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>); <span class="comment">//在需要时声明</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">    b.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>CommonJS 就是我们在 nodejs 中见到的模块用法，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;</span><br><span class="line"><span class="built_in">exports</span>.hello = <span class="function">() =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>CommonJS 特点：</p><ol><li>是<strong>同步加载</strong>其他模块，这是 commonjs 与 AMD 模块化方案最大的不同之处。CommonJS 规范是为服务端设计，而 nodejs 是服务端编程，因为文件在本地都可以直接访问，所以不需要异步加载，而浏览器需要项服务端加载。</li><li>是<strong>运行时加载</strong>，这是与 ESM 不同之处，也是由于这个原因，使用 commonjs 编写的代码不支持 tree-shaking，因此 rollup 说是面向未来的编译工具，其实就是直接支持了 ESM 而不是 commonjs 模块化。</li><li>暴露出来的是<strong>值拷贝</strong>，即一旦输出某个值，模块内部的变化就影响不到这个值。</li></ol><h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><p>ES Module 是基于语言层面的模块化解决方案，旨在成为浏览器和服务器通用的模块解决方案，也是 javascript 模块化未来的发展方向，现在主流的浏览器已经支持了。最近较火的 snowpack 和 vite 就是利用浏览器原生支持 ESM 的特点，快速编译构建开发环境可用的代码。如果不考虑低版本浏览器兼容性的话，可用直接在浏览器环境上 ESM 语法了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lodash <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>ESM 特点：</p><ol><li>是<strong>编译时加载</strong>，它具有声明提升效果，ES 模块允许进行静态分析。正如此，rollup/webapck 等打包工具都提供了 Tree-shaking 优化，用于清除实际上在项目中没有用到的代码，使代码运行更加高效。</li><li>暴露出来的是<strong>值引用</strong>，这是与 CommonJS 的不同之处。</li></ol><h2 id="ESM-与-CommonJS-的差异"><a href="#ESM-与-CommonJS-的差异" class="headerlink" title="ESM 与 CommonJS 的差异"></a>ESM 与 CommonJS 的差异</h2><ol><li>ESM 输出的是值引用， CommonJS 输出的是值拷贝。</li><li>ESM 是编译时加载，CommonJS 是运行时加载。</li></ol><h2 id="模块化方案总结"><a href="#模块化方案总结" class="headerlink" title="模块化方案总结"></a>模块化方案总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/116852/1589097006069-26ff4802-c83d-49de-8201-b7257781f6da.png#align=left&display=inline&height=278&margin=%5Bobject%20Object%5D&originHeight=278&originWidth=1133&size=0&status=done&style=none&width=1133"></p><hr><p>参考资料：</p><ul><li><a href="https://juejin.im/post/6844903576309858318">前端模块化：CommonJS,AMD,CMD,ES6 </a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
            <tag> CommonJS </tag>
            
            <tag> ESModule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解读this</title>
      <link href="/post/5d6f7988/"/>
      <url>/post/5d6f7988/</url>
      
        <content type="html"><![CDATA[<h2 id="指向"><a href="#指向" class="headerlink" title="指向"></a>指向</h2><p>在 ES5 中，this 的指向原则是：在函数调用的时候确认指向，<strong>this 永远指向最后调用它的那个对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;globalName&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;scopedName&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(); <span class="comment">// globalName</span></span><br></pre></td></tr></table></figure><p>上面代码中 print 函数是通过 <code>print()</code>  调用，那么在非严格模式下调用对象默认就是 window，因此最后输出的是 <code>globalName</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;globalName&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;scopedName&#x27;</span>,</span><br><span class="line">  <span class="attr">print</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.print(); <span class="comment">// scopedName</span></span><br></pre></td></tr></table></figure><p>上面代码中 print 函数是通过 <code>foo.print()</code>  调用，那么根据规则，调用它的对象是 foo，因此最后输出的是 <code>scopedName</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;globalName&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;scopedName&#x27;</span>,</span><br><span class="line">  <span class="attr">print</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = foo.print;</span><br><span class="line"></span><br><span class="line">foo.print(); <span class="comment">// scopedName</span></span><br><span class="line">bar(); <span class="comment">// globalName</span></span><br></pre></td></tr></table></figure><p>上面代码出现了两种调用形式：一种是通过 <code>foo.print()</code>  直接调用，此时调用它的对象是 foo，根据规则，最后输出的是  <code>scopedName</code> ；另一种是先将 foo.print 赋值给 bar 变量，然后通过 <code>bar()</code> 调用，根据规则，最后输出的是 <code>globalName</code> 。通过对比这两种函数调用的形式，可以发现 this 的指向由函数最终调用的对象决定，而与定义时无关。</p><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p>在 javascript 中，this 指向的绑定有以下四种：</p><ul><li>默认绑定：非严格模式情况下，this 指向 window, 严格模式下，this 指向 undefined</li><li>隐式绑定：如果函数调用时，前面存在调用它的对象，那么 this 就会隐式绑定到这个对象上</li><li>显示绑定：函数通过 call/apply/bind 调用，this 指向被绑定的对象</li><li>new 绑定：函数被 new 调用，this 指向新构造出来的那个对象</li></ul><p>前几种较为常见很好理解，这里说下使用 new 调用函数，或者发生构造函数调用时，会自动执行下面操作：</p><ol><li>创建一个全新的对象</li><li>将新对象的 <code>[[prototype]]</code> （即非 ecma 标准的 <code>__proto__</code>  属性）绑定到构造函数的 prototype</li><li>这个新对象会绑定到函数调用的 this</li><li>如果这个函数没有返回其他对象，那么 new 表达式中的函数会自动调用这个新对象</li></ol><p>在 javascript 中，new 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。在 JavaScript 中，所有的函数都可以被 new 调用，这时候这个函数一般会被称为“构造函数”，实际上并不存在所谓“构造函数”，更确切的理解应该是对于函数的 “构造器调用模式”。</p><h2 id="绑定规则的优先级"><a href="#绑定规则的优先级" class="headerlink" title="绑定规则的优先级"></a>绑定规则的优先级</h2><p>new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>快速定位 this 指向的方式（按优先级排序）：</p><ol><li>如果使用 new 关键字调用函数，那么 this 指向实例对象</li><li>如果使用 call/apply/bind 调用函数，那么 this 指向显式绑定的对象</li><li>如果函数被作为对象的方法调用，那么 this 指向这个对象</li><li>如果函数被作为自由函数调用，那么 this 指向全局对象</li><li>箭头函数中 this 是定义时所在的对象，而不是使用时所在的对象</li></ol><hr><p>参考：</p><ol><li><a href="https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3">The Simple Rules to ‘this’ in Javascript</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue组件通信方式总结</title>
      <link href="/post/e5f8cda2/"/>
      <url>/post/e5f8cda2/</url>
      
        <content type="html"><![CDATA[<p>使用 Vue 进行项目开发，一个不可避免的问题就是如何实现组件间通信。本文记录组件开发经常用到的组件间通信方式：</p><ul><li>props / $emit</li><li>$refs / $parent / $children</li><li>$attrs / $listeners</li><li>peovide / inject</li><li>EventBus</li><li>vuex</li><li>.sync</li></ul><h3 id="props-emit"><a href="#props-emit" class="headerlink" title="props / emit"></a>props / emit</h3><p>组件通信最常用的就是这种方法，父组件通过 <code>props</code> 将数据传递给子组件，子组建通过 <code>$emit</code> 触发相应事件将数据回传父组件。相对应的， <code>v-model</code>  指令、 <code>.sync</code>  修饰符都是这类通信方式的语法糖。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span></span><br><span class="line">    // 在父组件利用 v-on 监听</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;click&#x27;, e)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">type</span>: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>官网文档：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/components-props.html">Prop</a></li><li><a href="https://cn.vuejs.org/v2/api/#vm-props">vm.$props</a></li><li><a href="https://cn.vuejs.org/v2/api/#vm-emit">vm.$emit</a></li></ul><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h3><p><code>provide</code> 和 <code>inject</code> 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。</p><p>官网文档：</p><ul><li><a href="https://cn.vuejs.org/v2/api/#provide-inject">provide/inject</a></li></ul><h3 id="refs-parent-children"><a href="#refs-parent-children" class="headerlink" title="refs / parent / children"></a>refs / parent / children</h3><p><code>$refs</code>  相较于其他两项更好用，因为它能更准确的找到对应组件实例，开发中常用于主动调用子组件的方法。<br><code>$parent</code>  和 <code>$children</code>  它们的主要目的是作为访问组件的应急方法，并不太推荐使用，因为在开发中有些场景不能判断父组件或子组件到底是哪个，可能中间还会包含其他组件，项目的维护成本会变相提高。更推荐用 props 和 events 实现父子组件通信。</p><p>官网文档：</p><ul><li><a href="https://cn.vuejs.org/v2/api/#ref">ref</a></li><li><a href="https://cn.vuejs.org/v2/api/#vm-refs">vm.$refs</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0">访问子组件实例或子元素</a></li><li><a href="https://cn.vuejs.org/v2/api/#parent">parent</a></li><li><a href="https://cn.vuejs.org/v2/api/#vm-parent">vm.$parent</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E7%88%B6%E7%BA%A7%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B">访问父级组件实例</a></li><li><a href="https://cn.vuejs.org/v2/api/#vm-children">vm.$children</a></li></ul><h3 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="attrs / listeners"></a>attrs / listeners</h3><p>这两个实例 property 在创建高级组件时非常有用，通常用来透传属性/方法。</p><ul><li><a href="https://cn.vuejs.org/v2/api/#vm-attrs">vm.$attrs</a></li><li><a href="https://cn.vuejs.org/v2/api/#vm-listeners">vm.$listeners</a></li></ul><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p><code>EventBus</code>  称为事件总线，在 vue 中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。EventBus 的实现实际是运用 vue 实例事件/方法： <code>$emit</code> , <code>$on</code> , <code>$off</code></p><p>使用 <code>EventBus</code> 实现组件通信，有以下几个步骤：</p><ol><li>初始化：首先需要创建一个事件总线并将其导出，以便其他模块可以使用或者监听它。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue();</span><br></pre></td></tr></table></figure><ol start="2"><li>发送事件：可以在任意组件中发送事件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> EventBus <span class="keyword">from</span> <span class="string">&#x27;./event-bus&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">name</span>: <span class="string">&#x27;ComponentA&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">num</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        EventBus.$emit(<span class="string">&#x27;addition&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">num</span>: <span class="built_in">this</span>.num++,</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>接收事件：可以在任意组件中接收事件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>结果: &#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> EventBus <span class="keyword">from</span> <span class="string">&#x27;./event-bus&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">name</span>: <span class="string">&#x27;ComponentB&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">count</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      EventBus.$on(<span class="string">&#x27;addition&#x27;</span>, <span class="function">(<span class="params">param</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.count = <span class="built_in">this</span>.count + param.num;</span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">beforeDestory</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 移除自定义事件监听</span></span></span><br><span class="line"><span class="javascript">      EventBus.$off(<span class="string">&#x27;addition&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>移除事件监听：最后别忘了在组件销毁的时候移除自定义事件监听</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> EventBus <span class="keyword">from</span> <span class="string">&#x27;./event-bus&#x27;</span>;</span><br><span class="line">EventBus.$off(<span class="string">&#x27;addition&#x27;</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure><p>官网文档：</p><ul><li><a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6">实例事件/方法</a></li><li><a href="https://cn.vuejs.org/v2/api/#vm-emit">vm.$emit</a></li><li><a href="https://cn.vuejs.org/v2/api/#vm-on">vm.$on</a></li><li><a href="https://cn.vuejs.org/v2/api/#vm-off">vm.$off</a></li></ul><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>官网文档：</p><ul><li><a href="https://vuex.vuejs.org/zh/">vuex</a></li></ul><p>后面的故事大家都知道了~</p><hr><p>参考文章:</p><ul><li><a href="https://juejin.im/post/5d267dcdf265da1b957081a3">vue 中 8 种组件通信方式</a></li><li><a href="https://juejin.im/post/5c5910faf265da2da15d9424">vue 组件通信总结(非 vuex 和 Event Bus)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 组件通信 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
